/* SCCS ID keywords, do not remove */
static char *sccsid = "@(#)r1util.pc	1.1 09/08/03";

/* PVCS ID keywords, do not remove      */
/* "$Workfile:   r1util.pc  $ $Revision:   2.2  $ $Modtime:   Dec 04 2012 20:18:42  $" */

/* Change history :-
 * DATE         : 31-10-97
 * CHANGED BY   : G Fletcher
 * DESCRIPTION  : client-server conversion
*/

#include <stdio.h>
#include <string.h>

#include "rmms.h"

EXEC SQL INCLUDE sqlext.h;

/************************************************************ 
* SQL common declaration area for PRO*C host variables      *
************************************************************/ 

EXEC SQL BEGIN DECLARE SECTION;
     VARCHAR sqldate[10];
     VARCHAR userid[66];
EXEC SQL END DECLARE SECTION;

extern char csv_separator;

/************************************************************ 
* Function Declaration area                                 *
************************************************************/ 
int atoi();

void rollback()
{ 
	EXEC SQL ROLLBACK WORK;
	return;
}

void nullfill(str,len)
char *str;
int  len;
{
int count;
   for (count =0 ; count < len; count++)
       str[count] = '\0';
}

BOOLEAN chkstr(str1,str2,chklen)
char *str1,*str2;
int chklen;
{
int i;
   for (i=0;(*(str1+i) == *(str2+i)) && (i < chklen);i++) ;
   if (i == chklen)
      return(TRUE);
   else
      return(FALSE);
}

BOOLEAN get_date(date)
char date[10];
/* Amended by Rod Strong 22-Dec-92: linking error occurred on Bull DPX/2 port,
   as there exists a standard C subroutine called getdate ("doubly defined"
   error).  Function renamed get_date, was getdate.  */
{
   EXEC SQL SELECT SYSDATE
            INTO :sqldate
            FROM DUAL;
   *(sqldate.arr + sqldate.len) = '\0';
   strcpy(date,(char *)sqldate.arr);
   return(TRUE);
}


/* getargs.c       G E T A R G S  and  G E T S T R S
                   - - - - - - -       - - - - - - -

Purpose: GETARGS: To get character and string arguments separated by commas
         from an input string given a format. This routine deals with
         blanks between commas OK (unlike sscanf). Example:

         char *line="22,,text line, ABCD"
         char a1[10],a2[10];
         int  i1,i2,noargs;

    then: noargs = getargs("ddss",line,i1,i2,a1,a2)
 returns: i1 as 22,
          i2 as 0,
          a1 as "text line",
          a2 as " ABCD"
         noargs as 4.

         GETSTRS: to get the addresses of arguments ins atring separated by
                  commas.

Calling Sequence:
         getargs(format,string,a1,a2,a3,a4,....);

         getstrs( string,args )
Input:   char *format   A string specifying the argument types expected,
                        d indicates int, s indicates string.

         char *string   String containing arguments separated by commas,
                             a ",," for a string returns a zero length
                        string.

         char *a1...    array to put output sting in
         or
         int  &a1,...   addresses of integer variables to put args in.

Output:  int  getargs   No. of arguments found, this will be a max of
                        strlen(format) and less if fewer arguments found.

         int getstrs    No. of arguments found.

         char *args[ ]  array containing addresses of each of the arguments
                        found.

Notes:   Results will be unpredictable if fewer output variables are
         provided in the call than required by format.

         MAXIMUM of 15 arguments ( ai's.)

Author:  Alan Goddard 5 May 88

Changes:
---------------------------------------------------------------------------
*/


union intORcharPTR {long int *ip; char *ap; } ;

getargs( format,line,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
char *format,*line;
union intORcharPTR a1;
union intORcharPTR a2;
union intORcharPTR a3;
union intORcharPTR a4;
union intORcharPTR a5;
union intORcharPTR a6;
union intORcharPTR a7;
union intORcharPTR a8;
union intORcharPTR a9;
union intORcharPTR a10;
union intORcharPTR a11;
union intORcharPTR a12;
union intORcharPTR a13;
union intORcharPTR a14;
union intORcharPTR a15;
{ char *args[15];
   int getstrs(),nf,noargs;

noargs = getstrs(line,args);      /* get arg addresses into args[] */

nf =  (int)strlen(format);
nf = (nf<noargs) ? nf:noargs;
format += nf-1;
switch (nf) {
    case 15: if (*format-- == 'd')  *a15.ip = atoi(args[14]);
            else                   strcpy(a15.ap,args[14]);
    case 14: if (*format-- == 'd')  *a14.ip = atoi(args[13]);
            else                   strcpy(a14.ap,args[13]);
    case 13: if (*format-- == 'd')  *a13.ip = atoi(args[12]);
            else                   strcpy(a13.ap,args[12]);
    case 12: if (*format-- == 'd')  *a12.ip = atoi(args[11]);
            else                   strcpy(a12.ap,args[11]);
    case 11: if (*format-- == 'd')  *a11.ip = atoi(args[10]);
            else                   strcpy(a11.ap,args[10]);
    case 10: if (*format-- == 'd')  *a10.ip = atoi(args[9]);
            else                   strcpy(a10.ap,args[9]);
    case  9: if (*format-- == 'd')  *a9.ip = atoi(args[8]);
            else                   strcpy(a9.ap,args[8]);
    case  8: if (*format-- == 'd')  *a8.ip = atoi(args[7]);
            else                   strcpy(a8.ap,args[7]);
    case  7: if (*format-- == 'd')  *a7.ip = atoi(args[6]);
            else                   strcpy(a7.ap,args[6]);
    case  6: if (*format-- == 'd')  *a6.ip = atoi(args[5]);
            else                   strcpy(a6.ap,args[5]);
    case  5: if (*format-- == 'd')  *a5.ip = atoi(args[4]);
            else                   strcpy(a5.ap,args[4]);
    case  4: if (*format-- == 'd')  *a4.ip = atoi(args[3]);
            else                   strcpy(a4.ap,args[3]);
    case  3: if (*format-- == 'd')  *a3.ip = atoi(args[2]);
            else                   strcpy(a3.ap,args[2]);
    case  2: if( *format-- == 'd')  *a2.ip = atoi(args[1]);
            else                   strcpy(a2.ap,args[1]);
    case  1: if( *format   == 'd')  *a1.ip = atoi(args[0]);
            else                   strcpy(a1.ap,args[0]);
    }

return(noargs);
}
/* --------------------------------------------------------------- */
/* getstrs

   returns the no of strings found (seperator = ',') in line

   input line

   output args - array of char pointers to line

   effects truncates line by inserting a 0 at pos of first comma
*/
                                       


int getstrs( line, args )
char *line,*args[];
{ int noargs=0,i;
 char *strchr(),*l;

while( line!= NULL && *line != '\0' ) {
    args[noargs++]=line;
    line=strchr(line,csv_separator);
    if( line != NULL ) *line++ = '\0';
    }
for(i=0;i<noargs;i++) /* take off trailing spaces */
    for(l=args[i], l+=strlen(l)-1 ; *l == ' ' ; *l-- = '\0');

return(noargs);
}

/* rmcaseup   
  This file replaces the standard toupper as defined in ctype.h
  this was necessary since the macro on the SUN only worked if the
  character being converted was not already uppercase               */


int rmcaseup(character)
int character;
{
     if (character >= 'A' && character <= 'Z')
           return(character);
     else
           return(character - 'a' + 'A');
}
