/* *******************************************************************
        Module Title    :  Load Inventory Data by Group
        Module Type     :  Pro*c

   CHANGE HISTORY :-
   DATE         : 01-SEP-97
   CHANGED BY   : G Fletcher
   DESCRIPTION  : 1.7 > 2.1 database conversion
	
   DATE         : 31-10-97
   CHANGED BY   : G Fletcher
   DESCRIPTION  : client-server conversion
**********************************************************************/

/* static char *sccsid="@(#)mai2105.pc	1.1 09/16/03"; */
/* Copyright (c) 2013 Bentley Systems Incorporated. All rights reserved. */

static char *sccsid = "$Workfile:   mai2105.pc  $ $Revision:   2.2  $ $Modtime:   Jul 02 2013 09:53:18  $";

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <errno.h>
#include "rmms.h"


EXEC SQL BEGIN DECLARE SECTION;
     short int    sql_dummy;
     short int    sect_length;
     long  int    distance;  /*running total of distance along group*/
     long  int    offset;   /*distance of starting point from start of group*/
     long  int    c_out_count = 0;

/*for inserts into temp table*/
     VARCHAR sql_st_chain[50][6];
     VARCHAR sql_end_chain[50][6];
     VARCHAR sql_grp_id[50][31];
     VARCHAR sql_grp_type[50][5];
     VARCHAR sql_c_card[50][300];

/*for retrieving info*/
     VARCHAR sql_rse_group[31];
     VARCHAR sql_rse_grp_type[5];

     VARCHAR sect_no[5];
     VARCHAR sect_id[20];
     VARCHAR sect_c_card[300];
     VARCHAR sys_date[25];
     VARCHAR h_dummy[80];
EXEC SQL END DECLARE SECTION;

/************************************************************
* Function Declaration area                                 *
************************************************************/

char *strchr();
void putrec();
void insertrecs();
void nullfill();
void split_group();
BOOLEAN check_seq_nos();
void finish();
char GBErrMsg[255];



FILE *ofi1;   /* output file (to feed into next stage of loader) */
FILE *ofi2;   /* output file for report */
long int  b_out_count = 0, b_in_count = 0;
long int  linecount = 0;
char direct[1], init[3], text[80], inv_date[6];
BOOLEAN seq_chk_req = FALSE;
char c_card[200];
char *j;

short EXDebug;
char *EXRepOutpath;

EXEC SQL INCLUDE sqlext.h;

main(argc, argv)
int argc;
char *argv[];
{
short int a_count = 0;  /* count of A type records written to output file */
char lfile[80],pathname1[50],pathname2[50];
long int i, noargs, c_in_count = 0;
char line[200],rectype;
char st_chain[6], end_chain[6];
char dummy[200];
char grp[31];
char grp_type[5];
FILE *lfi;    /* load (input) file */
#ifndef ibm
   FILE *fopen();
#endif


	jobmain(argc,argv);
	
  	get_params(2);

   strcpy(pathname1,(char *)EXParam[0].arr);
   strcpy(pathname2,EXRepOutpath);

   if ( ( ofi1 = fopen(pathname1,"w") ) == NULL )
   {
      sprintf(GBErrMsg,"%s %s",pathname1,strerror(errno));
	  jobend(EXJobId,1,GBErrMsg);
	  EXEC SQL COMMIT WORK;
	  dblogoff();
      exit(EX_FAIL);
   }
   if ( ( ofi2 = fopen(pathname2,"w") ) == NULL )
   {
      sprintf(GBErrMsg,"%s %s",pathname2,strerror(errno));
	  jobend(EXJobId,1,GBErrMsg);
	  EXEC SQL COMMIT WORK;
	  dblogoff();
      exit(EX_FAIL);
   }

#ifdef ibm
    if (fopen((char *)EXParam[1].arr,"r") == NULL)
#else
    if (access((char *)EXParam[1].arr,4) == -1)
#endif
    {
        printf("\nERROR: No read access allowed to this Load file");
        printf(" BPR-8101\n");
        printf("***********************************************");
        printf("*********\n:");
        sprintf(GBErrMsg,"%s  %s",EXParam[1].arr,strerror(errno));
	    jobend(EXJobId,1,GBErrMsg);
 		EXEC SQL COMMIT WORK;
 		dblogoff();
        exit(EX_FAIL);
    }

   EXEC SQL DECLARE BPR2105_TMP TABLE 
			(GRP_ID      VARCHAR(30),
             GRP_TYPE    VARCHAR(5),
             START_CHAIN CHAR (9),
	      	 END_CHAIN   CHAR (9),
			 C_CARD	  	 CHAR(178));
   EXEC SQL CREATE TABLE BPR2105_TMP (GRP_ID      VARCHAR(30),
                                      GRP_TYPE    VARCHAR(5),
                                      START_CHAIN CHAR (9),
				      END_CHAIN   CHAR (9),
				      C_CARD	  CHAR(178));

   EXEC SQL SELECT SYSDATE,USER
            INTO :sys_date, :h_dummy
            FROM DUAL;

   printf("\nINFO: Processing and expanding file %s into %s BPR-8083\n\n",
          (char *)EXParam[1].arr,pathname1);
   fprintf(ofi2,"\n\nBPR2105       SPLITTING HUSKY HUNTER GROUP DATA INTO"
           " SECTIONS       %s\n\n",sys_date.arr);
   fprintf(ofi2,"\n*** Processing and expanding file %s into %s BPR-8083 ***"
           "\n\n",(char *)EXParam[1].arr,pathname1);

   lfi = fopen((char *)EXParam[1].arr,"r");

#ifdef ibm
   while (TRUE)
#else
   while (!feof(lfi))
#endif

   {
      nullfill(line,200);
      nullfill(c_card,200);

#ifdef ibm
      eofyn = fgets(line,200,lfi);
#else
      fgets(line,200,lfi);
#endif

#ifndef ibm

      linecount++;
      if (strlen(line) > 178)
      {
         sprintf(GBErrMsg,"\n** line %5d - ERROR: String exceeds maximum load length BPR-8013 **\n\n\n",linecount);
         finish();
      }
#endif

      rectype = line[1];

      if (linecount == 1 && rectype != 'A')
      {
         sprintf(GBErrMsg,"\n** ERROR: non A record type encountered at start of file BPR-8103 **\n\n\n");
         finish();
      } 

      switch(rectype)
      {
         case 'A' : if (++a_count > 1)
                    {
                       sprintf(GBErrMsg,"\n** ERROR: Input file contains more than one A type record BPR-8108 **\n\n\n");
                       finish();
                    }
                    fprintf(ofi1, "\"A,%s\"\n", pathname1);
                    break;

         case 'B' : b_in_count++;
                    noargs = getargs("ssssssssd", line, dummy, grp, dummy,
                    inv_date, direct, init, text, grp_type, &offset);
                    if (noargs != 9)
                    {

                       sprintf(GBErrMsg,"\n** line %5d - ERROR: %d fields in B type record BPR-8014 **\n\n\n",linecount, noargs-1);
                       finish();
                    }
                    if (offset > 0)
                       seq_chk_req = TRUE;
                    break;

         case 'C' : c_in_count++;
                    strcpy(c_card,line);
                    noargs = getargs("ssssssssss", line, dummy,
	            dummy, dummy, st_chain, end_chain, dummy, dummy,
	            dummy, dummy, dummy);
	            putrec(st_chain, end_chain, c_card, grp, grp_type);
	            break;
         case 'Z' : if (b_in_count == 0)
                    {
                       sprintf(GBErrMsg,"\n*** ERROR: No B type records were encountered BPR8121 ***\n\n\n");
                       finish();
                    }
                    if (c_in_count == 0)
                    {
                       sprintf(GBErrMsg,"\n*** ERROR: No C type records were encountered BPR8122 ***\n\n\n");
                       finish();
                    }
                    insertrecs();
                    split_group();
                    fprintf(ofi1, "\"Z,%4.d,%4.d,",b_out_count,c_out_count);
                    for ( i = 13; i < strlen(line); i++ )
                       fprintf(ofi1, "%c", line[i]);
                    EXEC SQL DROP TABLE BPR2105_TMP;
	  				jobend(EXJobId,0,"");
	  				EXEC SQL COMMIT WORK;
                    dblogoff();
                    printf("\n\nINFO: Input file consists of %d road group(s) "
                           "and %d inventory record(s)\n\n",
                           b_in_count,c_in_count);
                    fprintf(ofi2,"\nINFO: Input file consists of %d road "
                            "group(s) and %d inventory record(s)\n\n",
                           b_in_count,c_in_count);
                    printf("\nINFO: File successfully expanded to %d road"
                       " sections and %d inventory records\nBPR-8081\n\n\n",
                             b_out_count,c_out_count);
                    fprintf(ofi2,"\nINFO: File successfully expanded to %d"
                            " road sections and %d inventory records"
                            "\nBPR-8081\n\n\n",b_out_count,c_out_count);
                    exit(EX_SUCC);
         default:   sprintf(GBErrMsg,"\n** ERROR: unknown record type encountered (or missing Z type record) BPR-8104 **\n\n\n");
                    finish();
      }
   }
}

/**** Checks to make sure all road sections in group have a unique, ****/ 
/**** not null sequence number                                      ****/
/***********************************************************************/

BOOLEAN check_seq_nos()
{
EXEC SQL SELECT 1
         INTO   :sql_dummy
         FROM   ROAD_SEG_MEMBS
         WHERE  RSM_RSE_HE_ID_IN = (SELECT RSE_HE_ID
                                    FROM   ROAD_SEGMENTS_ALL
                                    WHERE  nvl(RSE_GTY_GROUP_TYPE,'@')
                                           = nvl(:sql_rse_grp_type,'@')
                                    AND    RSE_GROUP = :sql_rse_group
                                    AND    RSE_TYPE = 'G')
         GROUP BY RSM_SEQ_NO
         HAVING COUNT(0) > 1;

   if (sqlca.sqlcode != 1403)
      return(FALSE);

EXEC SQL SELECT 1
         INTO   :sql_dummy
         FROM   ROAD_SEG_MEMBS
         WHERE  RSM_RSE_HE_ID_IN = (SELECT RSE_HE_ID
                                    FROM   ROAD_SEGMENTS_ALL
                                    WHERE  nvl(RSE_GTY_GROUP_TYPE,'@')
                                           = nvl(:sql_rse_grp_type,'@')
                                    AND    RSE_GROUP = :sql_rse_group
                                    AND    RSE_TYPE = 'G')
         AND    RSM_SEQ_NO IS NULL;

   if (sqlca.sqlcode != 1403)
      return(FALSE);
   else
      return(TRUE);
}

/**** splits the group into the road sections within it and writes a ****/
/**** B record to the output file for each section which will have   ****/
/**** inventory created against it. C records with the chainages     ****/
/**** relative to the section ajusted to account for the offset are  ****/
/**** written to the output file for each affected section           ****/
/************************************************************************/

void split_group()
{
BOOLEAN b_record_written;
long int i;
signed int ii;

EXEC SQL DECLARE C1 CURSOR FOR
         SELECT RSE1.RSE_GROUP
	       ,RSE1.RSE_SECT_NO
               ,RSE1.RSE_lENGTH
         FROM   ROAD_SEGMENTS_ALL RSE1
               ,ROAD_SEG_MEMBS
         WHERE  RSE1.RSE_HE_ID = RSM_RSE_HE_ID_OF
         AND    RSM_RSE_HE_ID_IN = (SELECT RSE2.RSE_HE_ID
                                    FROM   ROAD_SEGMENTS_ALL RSE2
                                    WHERE  nvl(RSE2.RSE_GTY_GROUP_TYPE,'@')
                                           = nvl(:sql_rse_grp_type,'@')
                                    AND    RSE2.RSE_GROUP = :sql_rse_group
                                    AND    RSE2.RSE_TYPE = 'G')
         ORDER BY RSM_SEQ_NO;

EXEC SQL DECLARE C2 CURSOR FOR
         SELECT SUBSTR(C_CARD,1,INSTR(C_CARD,',',1,3))||
                LPAD(
                DECODE(SIGN(NVL(START_CHAIN,0) - (:distance - :sect_length)),1,
                       START_CHAIN - (:distance - :sect_length),
                       DECODE(SIGN(:offset - (:distance - :sect_length)),1,
                       :offset - (:distance - :sect_length),0)),4,' ')
                ||','||
                LPAD(
                DECODE(NVL(END_CHAIN,0), 0, :sect_length,
                DECODE(SIGN(END_CHAIN - :distance), -1,
                       END_CHAIN - (:distance - :sect_length), :sect_length)),
                4, ' ')||
                SUBSTR(C_CARD,INSTR(C_CARD,',',1,5))
         FROM   BPR2105_TMP
         WHERE  NVL(START_CHAIN,:distance-1) < :distance
         AND    NVL(END_CHAIN,:distance+1) > :distance - :sect_length
         AND    GRP_ID = :sql_rse_group;

EXEC SQL DECLARE C3 CURSOR FOR
         SELECT   GRP_ID
                 ,GRP_TYPE
         FROM     BPR2105_TMP
         GROUP BY GRP_ID
                 ,GRP_TYPE;

   c_out_count = 0;

EXEC SQL OPEN C3;

   while (TRUE)
   {
EXEC SQL FETCH C3 INTO :sql_rse_group
                      ,:sql_rse_grp_type;

      if (sqlca.sqlcode == 1403)
         break;

      if (seq_chk_req == TRUE)
      {
         if (check_seq_nos() == FALSE)
         {
            sprintf(GBErrMsg,"\n**ERROR: Road section sequence numbers are not unique or at least one is null**\n(Group: %s) BPR-8080\n\n\n",sql_rse_group.arr);
            finish();
         }
      }
      distance = 0;

EXEC SQL OPEN C1;

      while (TRUE)
      {

EXEC SQL FETCH C1 INTO :sect_id
                      ,:sect_no
                      ,:sect_length;

         if (sqlca.sqlcode == 1403)
            break;
         else
            b_record_written = FALSE;

         sect_id.arr[sect_id.len] = '\0';
         sect_no.arr[sect_no.len] = '\0';

         distance += sect_length;
         if (distance > offset)
         {

EXEC SQL OPEN C2;

            while (TRUE)
            {

EXEC SQL FETCH C2 INTO :sect_c_card;

               if (sqlca.sqlcode == 1403)
                  break;
               if (b_record_written == FALSE)
               {
                  fprintf(ofi1, "\"B,%s,%s,%6.6s,%1.1s,%3.3s,%s\"\n",
                         sect_id.arr,sect_no.arr, inv_date, direct, init, text);
                  b_out_count++;
                  b_record_written = TRUE;
               }
               sect_c_card.arr[sect_c_card.len] = '\0';
               for (j = ((char *)sect_c_card.arr + strlen((char *)sect_c_card.arr) -1 );
                    isspace(*j); *j-- = '\0');

               fprintf(ofi1,"%s\n",sect_c_card.arr);
               c_out_count++;
            }
  
EXEC SQL CLOSE C2;
         }
      }
EXEC SQL CLOSE C1;
   }
}

void nullfill(str,len)
char *str;
long int  len;
{
long int count;

   for (count =0 ; count < len; count++)
       str[count] = '\0';
}

void putrec(st_ch, end_ch, card, grp, type)
char *st_ch, *end_ch, *card, *grp, *type;
{  
short int i;

   for (i = 0; i < strlen(st_ch); i++)
   {
      if (isalpha(st_ch[i]))
      {
         sprintf(GBErrMsg,"\n** line %5d - ERROR: A letter has been found in a chainage field BPR-8082 **\n\n\n",linecount);
         finish();
      }
   }
   for (i = 0; i < strlen(end_ch); i++)
   {
      if (isalpha(end_ch[i]))
      {
         sprintf(GBErrMsg,"\n** line %5d - ERROR: A letter has been found in a chainage field BPR-8082 **\n\n\n",linecount);
         finish();
      }
   }

/****  if chainage is null then insert null, otherwise add the offset  ****/
/****  and then insert (into temp table)                               ****/
/**************************************************************************/

   if (strlen(st_ch) == 0)
   {
      strcpy((char*)sql_st_chain[c_out_count].arr,st_ch);
      sql_st_chain[c_out_count].len = 0;
   }
   else
   {
      seq_chk_req = TRUE;
      sprintf((char *)sql_st_chain[c_out_count].arr,"%d",atoi(st_ch) + offset);
      sql_st_chain[c_out_count].len = strlen((char *)sql_st_chain[c_out_count].arr);
   }
   if (strlen(end_ch) == 0)
   {
      strcpy((char*)sql_end_chain[c_out_count].arr,end_ch);
      sql_end_chain[c_out_count].len = 0;
   }
   else
   {
      seq_chk_req = TRUE;
      sprintf((char *)sql_end_chain[c_out_count].arr,"%d",atoi(end_ch) + offset);
      sql_end_chain[c_out_count].len = strlen((char *)sql_end_chain[c_out_count].arr);
   }

   strcpy((char*)sql_grp_id[c_out_count].arr,grp);
   sql_grp_id[c_out_count].len = strlen(grp);

   strcpy((char*)sql_grp_type[c_out_count].arr,type);
   sql_grp_type[c_out_count].len = strlen(type);

   strcpy((char*)sql_c_card[c_out_count].arr,card);
   sql_c_card[c_out_count].len = strlen((char *)sql_c_card[c_out_count].arr);

   if (++c_out_count == 50)
      insertrecs();
}

void insertrecs()
{
   EXEC SQL FOR :c_out_count INSERT INTO BPR2105_TMP
  	                 VALUES( :sql_grp_id
                                ,:sql_grp_type
                                ,:sql_st_chain
 	                        ,:sql_end_chain
                                ,:sql_c_card);
   c_out_count = 0;
}

BOOLEAN chkstr(str1,str2,chklen)
char *str1,*str2;
long int chklen;
{
long int i;
   for (i=0;(*(str1+i) == *(str2+i)) && (i < chklen);i++) ;
   if (i == chklen)
      return(TRUE);
   else
      return(FALSE);
}

/* getargs.c       G E T A R G S  and  G E T S T R S
                   - - - - - - -       - - - - - - -

Purpose: GETARGS: To get character and string arguments separated by commas
         from an input string given a format. This routine deals with
         blanks between commas OK (unlike sscanf). Example:

         char *line="22,,text line, ABCD"
         char a1[10],a2[10];
         int  i1,i2,noargs;

    then: noargs = getargs("ddss",line,i1,i2,a1,a2)
 returns: i1 as 22,
          i2 as 0,
          a1 as "text line",
          a2 as " ABCD"
         noargs as 4.

         GETSTRS: to get the addresses of arguments ins atring separated by
                  commas.

Calling Sequence:
         getargs(format,string,a1,a2,a3,a4,....);

         getstrs( string,args )
Input:   char *format   A string specifying the argument types expected,
                        d indicates int, s indicates string.

         char *string   String containing arguments separated by commas,
                             a ",," for a string returns a zero length
                        string.

         char *a1...    array to put output sting in
         or
         int  &a1,...   addresses of integer variables to put args in.

Output:  int  getargs   No. of arguments found, this will be a max of
                        strlen(format) and less if fewer arguments found.

         int getstrs    No. of arguments found.

         char *args[ ]  array containing addresses of each of the arguments
                        found.

Notes:   Results will be unpredictable if fewer output variables are
         provided in the call than required by format.

         MAXIMUM of 15 arguments ( ai's.)

Author:  Alan Goddard 5 May 88

Changes:
---------------------------------------------------------------------------
*/
/* MODIFIED BY: Steve Voller
   REASON     : Porting problem with the union iors line. DRS6000 dumps
                the core at this point therfore #ifdef introduced.
   DATE       : 14-SEP-91
*/

#ifdef sparc
union iors {long int ip[40]; char ap[40];} ;
#else
union iors {long int *ip; char *ap;} ;
#endif

getargs( format,line,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15)
char *format,*line;
union iors  a1;
union iors  a2;
union iors  a3;
union iors  a4;
union iors  a5;
union iors  a6;
union iors  a7;
union iors  a8;
union iors  a9;
union iors  a10;
union iors  a11;
union iors  a12;
union iors  a13;
union iors  a14;
union iors  a15;
{ char *args[15];
   int getstrs(),nf,noargs;
   
noargs = getstrs(line,args);

nf =  strlen(format);
nf = (nf<noargs) ? nf:noargs;
format += nf-1;
switch (nf) {
    case 15: if (*format-- == 'd')  *a15.ip = atoi(args[14]);
            else                   strcpy(a15.ap,args[14]);
    case 14: if (*format-- == 'd')  *a14.ip = atoi(args[13]);
            else                   strcpy(a14.ap,args[13]);
    case 13: if (*format-- == 'd')  *a13.ip = atoi(args[12]);
            else                   strcpy(a13.ap,args[12]);
    case 12: if (*format-- == 'd')  *a12.ip = atoi(args[11]);
            else                   strcpy(a12.ap,args[11]);
    case 11: if (*format-- == 'd')  *a11.ip = atoi(args[10]);
            else                   strcpy(a11.ap,args[10]);
    case 10: if (*format-- == 'd')  *a10.ip = atoi(args[9]);
            else                   strcpy(a10.ap,args[9]);
    case  9: if (*format-- == 'd')  *a9.ip = atoi(args[8]);
            else                   strcpy(a9.ap,args[8]);
    case  8: if (*format-- == 'd')  *a8.ip = atoi(args[7]);
            else                   strcpy(a8.ap,args[7]);
    case  7: if (*format-- == 'd')  *a7.ip = atoi(args[6]);
            else                   strcpy(a7.ap,args[6]);
    case  6: if (*format-- == 'd')  *a6.ip = atoi(args[5]);
            else                   strcpy(a6.ap,args[5]);
    case  5: if (*format-- == 'd')  *a5.ip = atoi(args[4]);
            else                   strcpy(a5.ap,args[4]);
    case  4: if (*format-- == 'd')  *a4.ip = atoi(args[3]);
            else                   strcpy(a4.ap,args[3]);
    case  3: if (*format-- == 'd')  *a3.ip = atoi(args[2]);
            else                   strcpy(a3.ap,args[2]);
    case  2: if( *format-- == 'd')  *a2.ip = atoi(args[1]);
            else                   strcpy(a2.ap,args[1]);
    case  1: if( *format   == 'd')  *a1.ip = atoi(args[0]);
            else                   strcpy(a1.ap,args[0]);
    }

return(noargs);
}
/* --------------------------------------------------------------- */
/* getstrs

   returns the no of strings found (seperator = ',') in line

   input line

   output args - array of char pointers to line

   effects truncates line by inserting a 0 at pos of first comma
*/


int getstrs( line, args )
char *line,*args[];
{ int noargs=0,i;
 char *strchr(),*l;

while( line!= NULL && *line != '\0' ) {
    args[noargs++]=line;
    line=strchr(line,',');
    if( line != NULL ) *line++ = '\0';
    }
for(i=0;i<noargs;i++)
    for(l=args[i], l+=strlen(l)-1 ; *l == ' ' ; *l-- = '\0');

return(noargs);
}
  
/* rmcaseup
   
  This file replaces the standard toupper as defined in ctype.h
  this was necessary since the macro on the SUN only worked if the
  character being converted was not already uppercase               */

int rmcaseup(character)
int character;
{
     if (character >= 'A' && character <= 'Z')
           return(character);
     else
           return(character - 'a' + 'A');
}


BOOLEAN chkabv(abv,str)
char *abv,*str;
{
int i;

if (strlen(abv) > strlen(str)) {return(FALSE);}
for (i=0;i<strlen(abv);i++)
{ if ((rmcaseup(abv[i]) != rmcaseup(str[i])) && (abv[i] != ' '))
     {return(FALSE);}
}
return(TRUE);
}

void finish()
{
   printf("\n** ERRORS DETECTED **\n\n");
	fputs(GBErrMsg,ofi2);
   fclose(ofi1);
   fclose(ofi2);
	EXEC SQL ROLLBACK WORK;
   EXEC SQL DROP TABLE BPR2105_TMP;
	jobend(EXJobId,1,GBErrMsg);
	EXEC SQL COMMIT WORK;
   dblogoff();
   exit(EX_FAIL);
}

void usersigfunc(sig)
int sig;
{
	printf("Signal %d received. Aborting ...",sig);
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,1,"Signal received causing abnormal program termination");
	EXEC SQL COMMIT WORK;
}
