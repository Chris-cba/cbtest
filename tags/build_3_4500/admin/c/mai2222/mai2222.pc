/* ==========================================================================
   *
   * Program      : mai2222 
   *
   * Author       : H.Buckley 
   * Version      : 1.0
   * Date         : 16-Oct-1995 
   *
   * Description  : This program has been designed to extract a series of
   *                codes and descriptions and to present the codes in an
   *                orderly format. The format of the file has been determined
   *                by Parkman Engineering as the file produced by this 
   *                program should be loadable into the Parkmans Roadline 350
   *                product. 
   *
   *                The program will be executed via the Highways GRI and
   *                should only accept parameters of Username/Password and
   *                GRI Job Id.
   *
   * Parameters   : GRI Report Parameters are :
   *                                  
   *                        a) Date From which data is valid.
   *                        b) Date To   which data valid 
   *                        c) User Identification value
   *
   * Note ........: Within this program there are large areas of comments and
   *                EXDebug code. This code should be left in place unless there
   *                are sufficient technical grounds or changes in standards to
   *                effect the removal of the code. 
   * CHANGE HISTORY :-
   * Date         :
   * Changed by   : 
   * Description  : The output file generated by this program should be named
   *                using the following data.
   * 
   *                a) The users initials
   *                b) A file sequence number. 
   *                c) .WIF ( Work Interface File ) extension. 
   * 
   * DATE         : 01-SEP-97
   * CHANGED BY   : G Fletcher
   * DESCRIPTION  : 1.7 > 2.1 database conversion
   *                         
   * DATE         : 05-11-97
   * CHANGED BY   : G Fletcher
   * DESCRIPTION  : client-server conversion
   ===========================================================================
   */

/*SCCS ID keyword, do not remove */
static char *sccsid = "@(#)mai2222.pc	1.1 09/16/03";
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "rmms.h"

short EXDebug=FALSE;
char *EXRepOutpath;
char pipe_msg[254];

#define FATAL       1                      /* FATAL constant declaration   */
#define SUCCESS     1                      /* SUCESS constant declaration  */
#define d_quote     '"'                    /* Quote character declaration  */
#define fld_sep     ','                    /* Field separator declaration  */
#define NUM_OF_UNITS 50                    /* Number of units in unit array*/

void nullfill();                           /* Prototype nullfill function  */

char GBErrMsg[255];

struct unit_types
      { char rec_type;                     /* Record Type                  */
        int  rec_number;                   /* The record type number       */ 
        char unit1[15];                    /* First Unit of measure        */
        char unit2[15];                    /* Second Unit of measure       */
        char unit3[15];                    /* Third Unit of measure        */
      };

EXEC SQL BEGIN DECLARE SECTION;

double     sta_min_quantity[50]           /* Minimum quantity             */
          ,sta_max_quantity[50]           /* Maximum quantity             */
;
int        rmms_flag                      /* Database type                */
;
varchar    full_date[19]                  /* The current date             */
          ,userid[66]                     /* User logon id                */
          ,sis_id[50][4]                  /* Standard item id             */
          ,sis_name[50][61]               /* Standard item name           */
          ,siss_id[50][4]                 /* Std item sub system code     */
          ,siss_name[50][61]              /* Std item sub system name     */
          ,siss_sis_id[50][4]             /* Std item sub-sub system code */
          ,sta_item_code[50][7]           /* Std item code                */
          ,sta_item_name[50][81]          /* Std item name                */
          ,sta_unit[50][11]               /* Std item unit                */
          ,sta_dim1_text[50][13]          /* Std item dimension 1         */
          ,sta_dim2_text[50][13]          /* Std item dimension 2         */
          ,sta_dim3_text[50][13]          /* Std item dimension 3         */
          ,parameters[50][255]            /* Report parameters            */
          ,p_initials[4]                  /* Users initials               */
          ,t_date[10]                     /* The current date             */
          ,temp_sis_id[4] 
          ,temp_siss_id[4]
;
short      parametersi[50]                /* Report parameters indicator  */
          ,sis_idi[50]                    /* Std item id indicator var    */
          ,sis_namei[50]                  /* Std item name indicator var  */
          ,siss_idi[50]                   /* Std item sub system variable */
          ,siss_namei[50]                 /* Std item name indicator var  */
          ,siss_sis_idi[50]               /* Std sub item indicator var   */
          ,sta_item_codei[50]             /* Std item code indicator var  */
          ,sta_item_namei[50]             /* Std item name indicator var  */
          ,sta_uniti[50]                  /* Std item unit indicator var  */
          ,sta_min_quantityi[50]          /* Std item min qty indicator   */
          ,sta_max_quantityi[50]          /* Std item max qty indicator   */
          ,parametersi[50]                /* Report parameters indicator  */
          ,t_datei                        /* Date indicator variable      */
          ,full_datei                     /* Full date indicator variable */
          ,rmms_flagi                     /* Rmms flag indicator variable */
          ,sta_dim1_texti[50]             /* Standard item imension 1 ind */
          ,sta_dim2_texti[50]             /* Standard item imension 2 ind */
          ,sta_dim3_texti[50]             /* Standard item imension 3 ind */
          ,i_temp_sis_id
          ,i_temp_siss_id
;
EXEC SQL END DECLARE SECTION;

int        job_id                         /* Selected  job id             */
          ,status=0                       /* Program status indicator     */
          ,recs[9]={0};                   /* Number of records of a type  */
char       *strchr();                     /* Pointer to strchr function   */
char       user_initials[3]               /* The selected users initials  */
;


char *EXRepOutpath;

struct unit_types unit_values[NUM_OF_UNITS]/* Array of type code_types     */
                 ,*c_ptr                   /* Array pointer                */
;

/************************************************************
* Standard I/O definition header file.                      *
************************************************************/


EXEC SQL INCLUDE sqlext.h;


main(argc,argv)
int argc;
char *argv[];
 {
  static     FILE *fp;        
  FILE       *open_cde_rep(); 
  int        i;

	jobmain(argc,argv);
	get_params(1);

    EXEC SQL SELECT hus_initials 
             INTO   :p_initials
             FROM   hig_users
             WHERE  hus_username=user;

    slen_varchar(p_initials);
    term_varchar(p_initials);
    strcpy(user_initials,(char *)p_initials.arr);

    do
    { 
    	strcat(user_initials,"_");
    } while ( strlen(user_initials) < 3 );

  initialize();
 
  dbase_type();
   
  fp=open_cde_rep();                         /* Create named output file.    */

  get_i_type_records(fp);

  get_j_type_records(fp);

  output_n_records(fp);

  get_z_type_records(fp);

  write_pipe(NULL,"Module completed successfully.");
  write_pipe(NULL,"File containing standard item data : ");
  write_pipe(NULL,EXRepOutpath);
  jobend(EXJobId,0,"");
  EXEC SQL COMMIT WORK;
  dblogoff();

  exit(SUCCESS);
}


/* =========================================================================
   * Displays the type of database being used by selection of the database  
   * type indicator from USER_DEFNS                                         
   *                                                                        
   * Displays a database narrative to describe the database type.           
   *                                                                        
   =========================================================================   
   */

int dbase_type()
{

  char database_type[30];

  EXEC SQL SELECT TO_NUMBER(HOP_VALUE)
                  ,to_char(sysdate,'DD-MON-YY:HH24::MI:SS')
                  ,to_char(sysdate,'DD-MON-YY')
           INTO   :rmms_flag:rmms_flagi
                  ,:full_date:full_datei
                  ,:t_date:t_datei
           FROM   HIG_OPTIONS
		   WHERE  HOP_ID='RMMSFLAG'
		   AND	  HOP_PRODUCT='HIG';

   switch ( rmms_flag )
   {
	  case 1 : strcpy(database_type,"Oracle DTp Standard");
			   break;
      case 2 : strcpy(database_type,"Hims/Oracle Hybrid");
			   break; 
      case 3 : strcpy(database_type,"Maintenance Manager");
			   break;
      case 4 : strcpy(database_type,"Welsh Office Standard");
			   break;
      default: strcpy(database_type,"**Unknown**");
			   break;
   }

   slen_varchar(t_date);
   term_varchar(t_date);

   strcpy(pipe_msg,"Database type is : ");
   strcat(pipe_msg,database_type);
   write_pipe(NULL,pipe_msg);

   printf("\nDatabase type is : %s\n",database_type);

   return(SUCCESS);
}

/* =========================================================================
 * Function : get_i_type_records
 * Descr    : This function should provide the program with the facility
 *            to put the first record into the data file.
 *
 * =========================================================================
 */
 
int get_i_type_records(fp)
FILE *fp;
{
   char title[]  = "NI Common Job Descriptions ";   
   char r_type[] = "I";
   char nullchar = ' ';
   char nullstg[]= "  ";

   if (EXDebug)
   {
   /* ...................... Put the information record to the screen     */
   printf("%c%s%c%-27s%-23s%c%-7s%c%c%c%-2s%c%-2s%c%-2s%c\n"
                          ,d_quote
                          ,r_type                 /* Record type          */
                          ,fld_sep                /* Field separator      */
                          ,title                  /* Constant title       */
                          ,t_date.arr             /* Date                 */
                          ,fld_sep                /* Field separator      */
                          ,nullstg                /* Null string          */
                          ,fld_sep                /* Field separator      */
                          ,nullchar               /* Null string          */
                          ,fld_sep                /* Field separator      */
                          ,nullstg                /* Null string          */
                          ,fld_sep                /* Field separator      */
                          ,nullstg                /* Null string          */
                          ,fld_sep                /* Field separator      */
                          ,nullstg                /* Null string          */
                          ,d_quote);              /* Double quote         */
   }

   /* .......................Put the information record to the file */
   fprintf(fp,"%c%s%c%-27s%-23s%c%-7s%c%c%c%-2s%c%-2s%c%-2s%c\n"
                              ,d_quote  
                              ,r_type             /* Record type          */
                              ,fld_sep            /* Field separator      */
                              ,title              /* Constant title       */
                              ,t_date.arr         /* Date                 */
                              ,fld_sep            /* Field separator      */
                              ,nullstg            /* Null field           */
                              ,fld_sep            /* Field separator      */
                              ,nullchar           /* Null field           */
                              ,fld_sep            /* Field separator      */
                              ,nullstg            /* Null field           */
                              ,fld_sep            /* Field separator      */
                              ,nullstg            /* Null field           */
                              ,fld_sep            /* Field separator      */
                              ,nullstg            /* Null field           */
                              ,d_quote);          /* Double quote         */

   return(SUCCESS);
}

/* =========================================================================
 * Function: get_j_type_records                                             
 *                                                                          
 * Obtain all 'J' type records from the database and format them into a     
 * buffer ready to be output to a specified datafile.                       
 *                                                                          
 * For each selected 'J' record types obtain all 'K' record types.          
 * For each selected 'K' record types obtain all 'L' record types.           
 *                                                                          
 * =========================================================================
 */

int get_j_type_records(fp)
FILE *fp;
{
    int  norecs  = 0 
	    ,j      
	    ,fin_yn  = 0 
   	    ,c_count = 0;
    char rec_type = 'J';
    char nullstg[]="    ";

    /* Cursor C1 should obtain all Standard Item records    */

    EXEC SQL DECLARE C1 CURSOR FOR
    SELECT   sis.sis_id
	        ,rpad(sis.sis_name,60)
            ,sis.sis_id
    FROM     standard_item_sections sis 
    WHERE  ( sis.sis_start_date is null
    AND      sis.sis_end_date is null  
    OR       to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')
    BETWEEN  nvl(sis.sis_start_date,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY'))
    AND      nvl(sis.sis_end_date  ,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')))
    AND      sis.sis_id > '0'; 
            
    EXEC SQL OPEN C1;

    while (!fin_yn)
    {

	EXEC SQL FETCH C1 INTO :sis_id:sis_idi
                          ,:sis_name:sis_namei
                          ,:siss_id:siss_idi;

	fin_yn  = (sqlca.sqlcode == EOFTCH) ? 1 : 0 ; 
	c_count = sqlca.sqlerrd[2] -norecs;       
	norecs  = sqlca.sqlerrd[2];               


    display_records("J",fin_yn,c_count,norecs);

	for ( j=0; j < c_count; ++j )
	{

      recs[0]=recs[0]+1;
      sis_idi[j]   = -1;
      term_varchar(sis_id[j]);
      strcpy((char *)temp_sis_id.arr,(char *)sis_id[j].arr);
      slen_varchar(temp_sis_id);
      i_temp_sis_id=-1;    

      sis_namei[j] = -1;
      term_varchar(sis_name[j]);

      siss_idi[j]  = -1;
      term_varchar(siss_id[j]);

      if (EXDebug)
      {
          printf("%c%c%c%3s%c%-60s%c%-4s%c\n"
                                   ,d_quote
                                   ,rec_type
                                   ,fld_sep
                                   ,sis_id[j].arr
                                   ,fld_sep
                                   ,sis_name[j].arr
                                   ,fld_sep
                                   ,nullstg
                                   ,d_quote);
      }

      fprintf(fp,"%c%c%c%3s%c%-60s%c%-4s%c\n"
                                   ,d_quote
                                   ,rec_type
                                   ,fld_sep
                                   ,sis_id[j].arr
                                   ,fld_sep
                                   ,sis_name[j].arr
                                   ,fld_sep
                                   ,nullstg
                                   ,d_quote);

      if (( status = get_k_type_records(fp))!= SUCCESS )
		{
  			EXEC SQL ROLLBACK WORK;
  			jobend(EXJobId,1,"get_k_type_records returned null");
  			EXEC SQL COMMIT WORK;
  			dblogoff();
			exit(EX_FAIL);
		}
     }
    }

	EXEC SQL CLOSE C1;
    return(SUCCESS);

    rec_err:
			sql_err(fp,"get_j_type_records");
            return(FATAL);
}

/* =========================================================================
 * Function: get_k_type_records                                             
 *                                                                          
 * Obtain all 'K' type records from the database and format them into a     
 * buffer ready to be output to a specified datafile.                       
 *                                                                          
 * =========================================================================
 */

int get_k_type_records(fp)
FILE *fp;
{
    int  norecs = 0
	    ,k      = 0
	    ,fin_yn = 0
   	    ,c_count= 0;
    char rec_type = 'K';
    char nullstg[]="    ";

    EXEC SQL DECLARE C2 CURSOR FOR
    SELECT   siss.siss_id
		    ,siss.siss_name
            ,siss.siss_id
    FROM     standard_item_sub_sections siss 
    WHERE    siss.siss_sis_id  = :temp_sis_id
    AND      exists  
           ( select 'exists' 
             from    standard_items sta
             where  sta.sta_siss_id = siss.siss_id ) 
    AND    ( siss.siss_start_date is null
    AND      siss.siss_end_date is null  
    OR       to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')
    BETWEEN  nvl(siss.siss_start_date,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY'))
    AND      nvl(siss.siss_end_date  ,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')))
    AND      siss.siss_id > '0';

    EXEC SQL OPEN C2;

    while (!fin_yn)
    {

	EXEC SQL FETCH C2 INTO :siss_id:siss_idi
                          ,:siss_name:siss_namei
                          ,:siss_sis_id:siss_sis_idi;

	fin_yn  = (sqlca.sqlcode == EOFTCH) ? 1 : 0 ; 
	c_count = sqlca.sqlerrd[2] -norecs;       
	norecs  = sqlca.sqlerrd[2];               

    display_records("K",fin_yn,c_count,norecs);
      
	for ( k=0; k < c_count; ++k )
	{
      recs[1]=recs[1]+1;
      siss_idi[k] = -1;
      term_varchar(siss_id[k]);
      strcpy((char *)temp_siss_id.arr,(char *)siss_id[k].arr);
      slen_varchar(temp_siss_id);

      siss_namei[k] = -1;
      term_varchar(siss_name[k]);

      siss_sis_idi[k] = -1;
      term_varchar(siss_sis_id[k]);

      if (EXDebug)
      {
          printf("%c%c%c%3s%c%-60s%c%-4s%c\n",d_quote
                                   ,rec_type
                                   ,fld_sep
                                   ,siss_sis_id[k].arr
                                   ,fld_sep
                                   ,siss_name[k].arr
                                   ,fld_sep
                                   ,nullstg
                                   ,d_quote);
      }


       fprintf(fp,"%c%c%c%3s%c%-60s%c%-4s%c\n",d_quote
                                    ,rec_type
                                    ,fld_sep
                                    ,siss_sis_id[k].arr
                                    ,fld_sep
                                    ,siss_name[k].arr
                                    ,fld_sep
                                    ,nullstg
                                    ,d_quote);

      if (( status = get_l_type_records(fp)) != SUCCESS )
		{
  			EXEC SQL ROLLBACK WORK;
  			jobend(EXJobId,1,"get_l_type_records returned null");
  			EXEC SQL COMMIT WORK;
  			dblogoff();
			exit(EX_FAIL);
		}
     }
    }

	EXEC SQL CLOSE C2;

    return(SUCCESS);
}


/* =========================================================================
 * Function: get_l_type_records                                             
 *                                                                          
 * Obtain all 'L' type records from the database and format them into a     
 * buffer ready to be output to a specified datafile.                       
 *                                                                          
 * =========================================================================
 */

int get_l_type_records(fp,siss_sis_id)
FILE *fp;
{
    int  norecs = 0                        /* Total number of records fetched */
	    ,l      = 0                        /* Integer counter                 */
	    ,fin_yn = 0                        /* Finished indicator              */
   	    ,c_count= 0                        /* Current number of fetched recs  */
        ,rec_num= 0                        /* Integer field reference value   */
        ,rec_val= 0
;
    char rec_buffer[250]                   /* Record buffer variable          */
        ,r_type = 'L'                      /* Record type constant            */
        ,fld_value_type='R'                 /* Currently a hard coded value. */
;

    EXEC SQL DECLARE C3 CURSOR FOR
    SELECT   sta.sta_item_code
		    ,sta.sta_item_name
		    ,sta.sta_unit
	        ,sta.sta_min_quantity
		    ,sta.sta_max_quantity
            ,sta.sta_dim1_text
            ,sta.sta_dim2_text
            ,sta.sta_dim3_text
    FROM     standard_items sta
    WHERE    sta.sta_siss_id   = :temp_siss_id
    AND  nvl(sta.sta_dcd_flag,'Y')='Y'
    AND  (   sta.sta_start_date is null
    AND      sta.sta_end_date   is null  
    OR       to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')
    BETWEEN  nvl(sta.sta_start_date,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY'))
    AND      nvl(sta.sta_end_date  ,to_date(nvl(:EXParam[0],sysdate),'DD-MON-YYYY')))
    AND      sta.sta_item_code > '0'; 

    EXEC SQL OPEN C3;

    while (!fin_yn)
    {
	EXEC SQL FETCH C3 INTO :sta_item_code:sta_item_codei
                          ,:sta_item_name:sta_item_namei
                          ,:sta_unit:sta_uniti
                          ,:sta_min_quantity
                          ,:sta_max_quantity
                          ,:sta_dim1_text:sta_dim1_texti
                          ,:sta_dim2_text:sta_dim2_texti
                          ,:sta_dim3_text:sta_dim3_texti;

	fin_yn  = (sqlca.sqlcode == EOFTCH) ? 1 : 0 ; 
	c_count = sqlca.sqlerrd[2] -norecs;       
	norecs  = sqlca.sqlerrd[2];               

   display_records("L",fin_yn,c_count,norecs);

	for (l=0;l<c_count;++l)
	{

      recs[2]=recs[2]+1;
      sta_item_codei[l] = -1;
      term_varchar(sta_item_code[l]);
 
      sta_item_namei[l] = -1;
      term_varchar(sta_item_name[l]);

      sta_uniti[l] = -1;
      term_varchar(sta_unit[l]);

      sta_dim1_texti[l]=-1; 
      term_varchar(sta_dim1_text[l]);
  
      sta_dim2_texti[l]=-1; 
      term_varchar(sta_dim2_text[l]);

      sta_dim3_texti[l]=-1; 
      term_varchar(sta_dim3_text[l]);

      /* ================================================================== 
       * At this point we should check the units against those units held
       * in the UNIT_TYPE array.            
       * ==================================================================
       */

       c_ptr=&unit_values[0];   /* Assign the pointer to the base address */
       while (1) 
       {  
           if (strcmp(c_ptr->unit1,"LAST_UNIT")==0)       /* First record */
           {
                strcpy(c_ptr->unit1,(char *)sta_dim1_text[l].arr);
                strcpy(c_ptr->unit2,(char *)sta_dim2_text[l].arr);
                strcpy(c_ptr->unit3,(char *)sta_dim3_text[l].arr);
                rec_val=c_ptr->rec_number;
                break;
           }
           else
             if ((strcmp(c_ptr->unit1,(char *)sta_dim1_text[l].arr)==0)
             &&  (strcmp(c_ptr->unit2,(char *)sta_dim2_text[l].arr)==0)
             &&  (strcmp(c_ptr->unit3,(char *)sta_dim3_text[l].arr)==0))
             {
                rec_val=c_ptr->rec_number;
                break;
             }
             else
                *c_ptr++;
         }   

          rec_num=0;
          
          if (strlen((char*)sta_dim1_text[l].arr)!=0)/* If the length of the first   */
          {                                  /* dimension narrative field is  */
               rec_num=1;                    /* greater than 0 then at least  */
          }                                  /* one dimension is required.    */

          if ((strlen((char*)sta_dim1_text[l].arr)!=0)/* If the length of thefirsttwo*/
          &&  (strlen((char*)sta_dim2_text[l].arr)!=0))/*dimensionnarrativefields are*/
          {                                  /* greater then 0 then at least  */
              rec_num=2;                     /* two dimensions are required.  */
          }

          if ((strlen((char*)sta_dim1_text[l].arr)!=0)/*Ifall three dimension fields */
          &&  (strlen((char*)sta_dim2_text[l].arr)!=0)/*aregreater than 0 in length  */
          &&  (strlen((char*)sta_dim3_text[l].arr)!=0))/*thenallthree dimensions are */
          {                                  /* required.                     */
              rec_num=3;
          }

       if (EXDebug)
       {
          printf("%c%c%c%10s%c%-80s%c%c%c%-15s%c%1d%c%2d%c%11.2f%c%11.2f%c%6c\n"
                                               ,d_quote 
                                               ,'L'
                                               ,fld_sep
                                               ,sta_item_code[l].arr
                                               ,fld_sep
                                               ,sta_item_name[l].arr
                                               ,fld_sep
                                               ,fld_value_type
                                               ,fld_sep
                                               ,sta_unit[l].arr
                                               ,fld_sep
                                               ,rec_num
                                               ,fld_sep
                                               ,rec_val
                                               ,fld_sep
                                               ,sta_min_quantity[l]
                                               ,fld_sep
                                               ,sta_max_quantity[l]
                                               ,fld_sep
                                               ,d_quote); 
      }

     fprintf(fp,"%c%c%c%10s%c%-80s%c%c%c%-15s%c%1d%c%2d%c%11.2f%c%11.2f%c%6c\n"
                                                ,d_quote 
                                                ,'L'
                                                ,fld_sep
                                                ,sta_item_code[l].arr
                                                ,fld_sep
                                                ,sta_item_name[l].arr
                                                ,fld_sep
                                                ,fld_value_type
                                                ,fld_sep
                                                ,sta_unit[l].arr
                                                ,fld_sep
                                                ,rec_num
                                                ,fld_sep
                                                ,rec_val
                                                ,fld_sep
                                                ,sta_min_quantity[l]
                                                ,fld_sep
                                                ,sta_max_quantity[l]
                                                ,fld_sep
                                                ,d_quote); 
     }
    } /* ============== End Of FOR Loop ================================= */

	EXEC SQL CLOSE C3;

    return(SUCCESS);
}


/* =========================================================================
 * Function: output_n_records                                               
 *                                                                          
 * This function should obtain the unit types used within this record type  
 * from an array that has been pre-populated.                                
 *                                                                          
 * =========================================================================
 */

int output_n_records(fp)
FILE *fp;
{
    char value_type='R';

    c_ptr=&unit_values[0];        /* Assign the pointer to the base assress */

    while (strcmp(c_ptr->unit1,"LAST_UNIT")!=0)  
    { 
         if (EXDebug)
         {
         printf("%c%c%c%2d%c%-15s%c%c%c%-15s%c%c%c%-15s%c%c%c%13c\n"
                                                 ,d_quote
                                                 ,c_ptr->rec_type
                                                 ,fld_sep
                                                 ,c_ptr->rec_number
                                                 ,fld_sep
                                                 ,c_ptr->unit1
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,c_ptr->unit2
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,c_ptr->unit3
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,d_quote );
         }
                      
         fprintf(fp,"%c%c%c%2d%c%-15s%c%c%c%-15s%c%c%c%-15s%c%c%c%13c\n"
                                                 ,d_quote
                                                 ,c_ptr->rec_type
                                                 ,fld_sep
                                                 ,c_ptr->rec_number
                                                 ,fld_sep
                                                 ,c_ptr->unit1
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,c_ptr->unit2
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,c_ptr->unit3
                                                 ,fld_sep
                                                 ,value_type
                                                 ,fld_sep
                                                 ,d_quote );

      *c_ptr++;     
      recs[3]++;
      } 

      return(SUCCESS);

}

/* =========================================================================
 * Function: get_z_type_records                                             
 *                                                                          
 * Obtain all 'Z' type records from the database and format them into a     
 * buffer ready to be output to a specified datafile.                       
 *                                                                          
 * =========================================================================
 */

int get_z_type_records(fp)
FILE *fp;
{
    char rec_type = 'Z';
    int  i;

    for ( i=0;i<4;i++ )
      recs[4]=recs[4]+recs[i];

    if (EXDebug)
    {
    printf("%c%c%c%03d%c%03d%c%03d%c%03d%c%03d%c\n"
                               ,d_quote
                               ,rec_type
                               ,fld_sep
                               ,recs[0]
                               ,fld_sep
                               ,recs[1]
                               ,fld_sep
                               ,recs[2]
                               ,fld_sep
                               ,recs[3]
                               ,fld_sep
                               ,recs[4]
                               ,d_quote);
    }

    fprintf(fp,"%c%c%c%03d%c%03d%c%03d%c%03d%c%03d%c\n"
                               ,d_quote
                               ,rec_type
                               ,fld_sep
                               ,recs[0]
                               ,fld_sep
                               ,recs[1]
                               ,fld_sep
                               ,recs[2]
                               ,fld_sep
                               ,recs[3]
                               ,fld_sep
                               ,recs[4]
                               ,d_quote);
    return(SUCCESS);

}

/* ============================================================================
 * Function : open_cde_rep()                                                   
 *                                                                             
 *                                                                             
 * Description : This function combines the initials of the user who isssues   
 *               the report and a number that is derrived from the number      
 *               of files found in the location specified by either the        
 *               environment variable PROD_FILEDIR or by the users HOME        
 *               environment variable. The file is suffixed with the .WIF      
 *               ( Work Interface File ) extension.                            
 * ============================================================================
 */ 
FILE *open_cde_rep()
{
FILE *fp; 
#ifndef IBM
FILE *fopen();
#endif

  if ((fp=fopen(EXRepOutpath,"w")) == NULL)
  {              
        write_pipe(NULL,"Unable to open output file for writing.");
        write_pipe(NULL,"File name for output is :");
        write_pipe(NULL,EXRepOutpath);
        write_pipe(NULL,"Aborting module run");
	sprintf(GBErrMsg,"%s %s",EXRepOutpath,strerror(errno));
        puts(GBErrMsg);
  	EXEC SQL ROLLBACK WORK;
  	jobend(EXJobId,1,GBErrMsg);
   	EXEC SQL COMMIT WORK;
   	dblogoff();
	exit(EX_FAIL);
  }
  
  return(fp);        /* Return file pointer of opened file */

 }

/* ==========================================================================
 * Function : display_records
 *
 *  Description : This function should be used to display the selected records
 *               for a s.elected record type.
 *
 * ========================================================================== 
 */

int display_records(r_type,f_n,c_c,n_r )
char *r_type;
int  f_n
    ,c_c
    ,n_r;
{
    int i;

    if (EXDebug)
    {
       printf("\n%s Type Records\n",r_type);
	   printf("Fin_yn : %d\n",f_n);
	   printf("c_count: %d\n",c_c);
	   printf("norecs : %d\n",n_r);
    } 

    return(SUCCESS);
}

/* =======================================================================
 * Function : nullfill
 * Purpose  : Fill the string argument with null characters to the full
 *            length of the string.
 * =======================================================================
 */
void nullfill(str,len)
char *str;
int  len;
{
int count;
   for (count =0 ; count < len; count++)
       str[count] = '\0';
}

/* ===========================================================================
 * Function : initialize()
 * Purpose  : Initialize the 'N' record array with required values.
 * ===========================================================================
 */
int initialize()
{
  int i;

  c_ptr=&unit_values[0];                      /* Initialize pointer to start  */


  for (i=0;i<NUM_OF_UNITS;i++)                /* For all array records        */
  {
     c_ptr->rec_type='N';                     /* Set record type              */
     c_ptr->rec_number=i+1;                   /* Set the record number        */
     strcpy(c_ptr->unit1,"LAST_UNIT");        /* Initialize first unit value  */
     nullfill(c_ptr->unit2,12);              /* Initialize second unit       */
     nullfill(c_ptr->unit3,12);              /* Initialize second unit       */
     *c_ptr++;                                /* Increment array pointer      */
  }
  
  
  if (EXDebug)
  {
      c_ptr=&unit_values[0];   

      puts("");
      puts("No Type Text1....... Text2....... Text3.......");
      for (i=0;i<NUM_OF_UNITS;i++)
      {
        printf("%2d %4c %12s %12s\n", c_ptr->rec_number
                                     ,c_ptr->rec_type
                                     ,c_ptr->unit1
                                     ,c_ptr->unit2
                                     ,c_ptr->unit3);
        *c_ptr++;
      }
  }

  return(SUCCESS);
}

void usersigfunc(sig)
int sig;
{
        write_pipe(NULL,"Fatal error received. Aborting module ...");
	printf("Signal %d received. Aborting ...",sig);
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,1,"Signal received causing abnormal program termination");
	EXEC SQL COMMIT WORK;
}
