/* ===========================================================================
 *
 * Program      : mai2224
 *
 * Author       : H.Buckley
 * Version      : 1.0
 * Date         : 06-Nov-1995
 * Description  : This program should produce a file of route data that
 *                has been extracted from various predefined data sets.
 *                The file to which the data is to be sent to should also
 *                be defined by the program.
 *
 * Parameters   : The report will be executed via the GRI ( Generic Reporting
 *                Interface ). GRI parameters required for the report are as
 *                follows :
 *                           EXParam[0]      : Administration Unit Code
 *                           EXParam[2]       : Road Group Type
 *                           ROAD_ID         : Selected Road Identifier
 *                           EXParam[1]  : Date From which data is valid.
 *                           TO_DATE         : Date To   which data is valid.
 *                           HIG_USER_ID     : User Identification
 *
 *                The GRI has the ability to provide a report with one or a
 *                list of a specified parameter. This has been implemented so
 *                that a user can produce a file based on a list of Road Groups
 *                Within the 'GRI0240 - Maintain Parameters' form there is a
 *                column headed 'No. Allowed' which is the number of parameters
 *                for the selected report module of that particular type.
 *                For the mai2224 program the value of thhis parameter will be
 *                1 for all parameters except that of the 'Road_Id' which has
 *                been set to 20 initially.
 *
 *                With the change in functionality of the report parameters for
 *                the Road_Id there will have to be a subsequent change to the
 *                actual mai2224 report to accomodate for the variable number of
 *                road id's that may be enterred by the users.
 *
 *                The report will NOT use REPORT_TAGS and therefore the report
 *                will work out the road network information for itself.
 *
 *                The output of this report will be contained within a file
 *                the name of which will be defined using a combination of
 *                the users initials and the selected sector. The file
 *                extension ,will be pre-defined as .RGF ( Road Group File ),
 *                the file naming convention has been agreed by ourselves
 *                in a meeting with the DOE ( NI ).
 *
 *                Route/Area file definition.
 *                Derek Maxwell wrote as part of his analysis :
 *                The Roadline 350 software will automatically detect the
 *                presence of the RLINE350.RTX file and will prompt the user
 *                wether the file is an AREA or SECTOR route file. If an
 *                existing file exists then the user must indicate wether to
 *                append the new file to the existing file or to overwrite
 *                the previous file with the new one. Roadline 350 software
 *                will sort the Road Sections in inspection Sequnce ORDER or
 *                Alphabetic order depending on wether the data is for a
 *                Sector or Area route file.
 *
 * CHANGE HISTORY :-
 *
 * Date         : 25-Jan-1996
 * Changed by   : H.Buckley
 * Description  : Clive Hackforth of Parkmans has informed me that the route
 *                number should be changed to a space filled field of 20
 *                characters. I have made the change to the Route record.
 *
 * DATE         : 01-SEP-97
 * CHANGED BY   : G Fletcher
 * DESCRIPTION  : 1.7 > 2.1 database conversion
 *
 * DATE         : 05-11-97
 * CHANGED BY   : G Fletcher
 * DESCRIPTION  : client-server conversion
 *
 * DATE         : 13-01-2000
 * CHANGED BY   : H.Buckley
 * DESCRIPTION  : The date parameter value used to obtain the section list
 *                was using param2 and should now use param1. The effective
 *                date parameter should now be the second in the reports gri
 *                parameter list.
 * ============================================================================
 */

#include <stdio.h>
#include <string.h>
#include <errno.h>
#include "rmms.h"

/*SCCS ID keyword, do not remove */
static char *sccsid = "@(#)mai2224.pc	1.2 10/14/05";


int rmms_flag;

#define EOFTCH  1403
#define BOOLEAN int
#define FALSE   0
#define SUCCESS 1
#define d_quote '"'
#define fld_sep ','

void get_params();
void nullfill(char *str,int len);
int get_s_type_records(FILE *fp);
int get_i_type_records(FILE *fp);
int get_p_type_records(FILE *fp);
int get_z_type_records(FILE *fp);
int display_records(char *r_type,int f_n,int c_c,int n_r);
int dbase_type();

EXEC SQL BEGIN DECLARE SECTION;

long int   road_id[50]                    /* The road identfier           */
          ,road_group                     /* Selected road group          */
          ,this_route                     /* Selected road route          */
          ,sect_seq_no[50]                /* Section sequence number      */
          ,job_id                         /* Job number                   */
;
int        sect_he_id[50]                 /* Section rse_he_id            */
;
varchar    full_date[12]                  /* Used for the file date       */
          ,half_date[5]                   /* Date in DDMM form            */
          ,userid[66]                     /* User Oracle Logon id         */
          ,route_group[50][21]            /* Route group name             */
          ,route_descr[50][41]            /* Route description            */
          ,sect_linkcode[50][11]          /* Section linkcode             */
          ,sect_sectno[50][6]             /* Section number               */
          ,sect_length[50][10]            /* Section length               */
          ,sect_descr[50][81]             /* Section description          */
          ,sect_environment[50][2]        /* Section Environment          */
          ,sect_traffic_level[50][2]      /* Section Traffic Level        */
          ,sect_class[50][3]              /* Section Class                */
          ,sect_road_type[50][3]          /* Section Type                 */
          ,p_initials[4]                  /* Users initials               */
          ,route_id[50][40]               /* Route identifier             */
;
short      route_descri[50]               /* Route description indicator  */
          ,route_idi[50]                  /* Route             indicator  */
          ,sect_linkcodei[50]             /* Section linkcode  indicator  */
          ,sect_sectnoi[50]               /* Section sectno    indicator  */
          ,sect_lengthi[50]               /* Section length    indicator  */
          ,sect_descri[50]                /* Section descr     indicator  */
          ,sect_seq_noi[50]               /* Section sequence number ind  */
          ,sect_environmenti[50]           /* Section Environment     ind  */
          ,sect_traffic_leveli[50]        /* Section Traffic Level   ind  */
          ,sect_classi[50]                /* Section Class     indicator  */
          ,sect_road_typei[50]            /* Section Type      indicator  */
          ,sect_he_idi[50]                /* Section rse_he_id indicator  */
          ,i_p_initials                   /* Persons initials parameter   */
          ,i_road_id[50]                  /* Road id indicator            */
          ,i_group[50]                    /* Road group indicator         */
;
EXEC SQL END DECLARE SECTION;

int        status=0                       /* Program status indicator     */
          ,recs[2]                        /* Number of records of a type
                                             recs[0] = Routes
                                             recs[1] = Sections
                                             recs[2] = recs[0]+recs[1]
                                             ............................ */
;
char       *strchr();
char       user_initials[2]               /* User initials                */
          ,file_suffix[3]="RGF"           /* Road Group File suffix       */
;
char GBErrMsg[255];
short EXDebug=FALSE;
char *EXRepOutpath;
char  file_date[5];                       /* File date                     */
char current_date[12];
char pipe_msg[254];

/* =========================================================================
 * Standard I/O definition header file.
 * =========================================================================
 */


EXEC SQL INCLUDE sqlext.h;

main(argc,argv)
/* =========================================================================
 * MAIN function called by none.
 *
 * Obtain program parameters.
 * Obtain database type.
 * Obtain report parameters.
 * Obtain all road group records.
 *
 * ========================================================================
 */
int argc;
char *argv[];
 {
  static     FILE *fp;
  FILE       *open_cde_rep();


  jobmain(argc,argv);
  get_params(3);

  job_id = atoi(argv[2]);

  dbase_type();

  EXEC SQL SELECT hus_initials
           INTO   :p_initials
           FROM   hig_users
           WHERE  hus_username=user;

  slen_varchar(p_initials);
  term_varchar(p_initials);
  strcpy(user_initials,(char *)p_initials.arr);

  do
  {
  	strcat(user_initials,"_");
  } while ( strlen(user_initials) < 3 );

  fp=open_cde_rep();

  get_i_type_records(fp);

  get_p_type_records(fp);

  get_z_type_records(fp);

  write_pipe(NULL,"Module completed successfully.");
  write_pipe(NULL,"File containing Network Data : ");
  strcpy(pipe_msg,"     ");
  strcat(pipe_msg,EXRepOutpath);
  write_pipe(NULL,pipe_msg);
  jobend(EXJobId,0,"");
  EXEC SQL COMMIT WORK;
  dblogoff();
  exit(0);

}


/* ===========================================================================
 * Displays the type of database being used by selection of the database
 * type indicator from USER_DEFNS
 *
 * Displays a database narrative to describe the database type.
 *
 * ===========================================================================
 *
 */
int dbase_type()
{

  char database_type[30];

  EXEC SQL SELECT TO_NUMBER(HOP_VALUE)
                  ,to_char(sysdate,'DDMM')
                  ,to_char(sysdate,'DD-MON-YYYY')
			INTO   :rmms_flag
                  ,:half_date
                  ,:full_date
           FROM   HIG_OPTIONS
		   WHERE  HOP_ID='RMMSFLAG'
		   AND	  HOP_PRODUCT='HIG';

   switch ( rmms_flag )
   {
	  case 1 : strcpy(database_type,"Oracle DTp Standard");
			   break;
      case 2 : strcpy(database_type,"Hims/Oracle Hybrid");
			   break;
      case 3 : strcpy(database_type,"Maintenance Manager");
			   break;
      case 4 : strcpy(database_type,"Welsh Office Standard");
			   break;
      default: strcpy(database_type,"**Unknown**");
			   break;
   }

   strcpy(pipe_msg,"Database type is : ");
   strcat(pipe_msg,database_type);
   write_pipe(NULL,pipe_msg);
   printf("\nDatabase type is : %s\n",database_type);

   slen_varchar(half_date);
   slen_varchar(full_date);
   term_varchar(half_date);
   term_varchar(full_date);
   strcpy(file_date,(char *)half_date.arr);
   strcpy(current_date,(char *)full_date.arr);

   return(SUCCESS);
}
/* ==========================================================================
 * Function : get_i_type_records
 * Descr    : This function should provide the program with the facility
 *            to put the first record into the data file.
 *
 * ==========================================================================
 *
 */
int get_i_type_records(fp)
FILE *fp;
{
   char title[]= "Selected Route Details",
       r_type ='I';


   if (EXDebug)
   {
   printf("%c%c%c%s%c%s%c\n",d_quote              /* Double quote         */
                          ,r_type                 /* Record type          */
                          ,fld_sep                /* Field separator      */
                          ,title                  /* Constant title       */
                          ,fld_sep                /* Field separator      */
                          ,current_date           /* Date                 */
                          ,d_quote);              /* Double quote         */
   }
   fprintf(fp,"%c%c%c%s%c%s%c\n",d_quote          /* Double quote         */
                              ,r_type             /* Record type          */
                              ,fld_sep            /* Field separator      */
                              ,title              /* Constant title       */
                              ,fld_sep            /* Field separator      */
                              ,current_date       /* Date                 */
                              ,d_quote);          /* Double quote         */

   return(SUCCESS);
}

/* ============================================================================
 * Function: get_r_type_records
 *
 * Obtain all 'R' type records from the database and format them into a
 * buffer ready to be output to a specified datafile.
 *
 * For each selected 'R' record types obtain all 'S' record types.
 *
 * ============================================================================
 */

int get_r_type_records(fp)
FILE *fp;
{
  int  norecs=0, i, fin_yn=0, c_count=0, group_he_id, dummy_level;
  char rec_type='R';

/* =======================================================================
* This cursor has been written to provide a list of all road groups for
* the selected report parameter.
* =======================================================================
*/

  EXEC SQL DECLARE C1 CURSOR FOR
  SELECT distinct rsm.rsm_rse_he_id_in
        ,level
    FROM road_seg_membs rsm
   WHERE sysdate between rsm.rsm_start_date
     AND nvl(rsm.rsm_end_date,sysdate)
 CONNECT by rsm.rsm_rse_he_id_in = prior rsm.rsm_rse_he_id_of
   START with rsm.rsm_rse_he_id_in = :road_group
   ORDER
      BY level
       ;

  EXEC SQL DECLARE C1A CURSOR FOR
  SELECT rse.rse_he_id
        ,rse.rse_group
        ,substr(replace(rse.rse_descr,',',';'),1,80)
    FROM road_segs rse
   WHERE rse.rse_he_id = :group_he_id
       ;

  EXEC SQL OPEN C1;

  while(!fin_yn)
    {
    EXEC SQL FETCH C1
    INTO :group_he_id
        ,:dummy_level;

    fin_yn  = (sqlca.sqlcode == EOFTCH) ? 1 : 0;
    c_count = sqlca.sqlerrd[2] -norecs;
    norecs  = sqlca.sqlerrd[2];

    EXEC SQL OPEN C1A;
    EXEC SQL FETCH C1A
    INTO :route_id:route_idi
        ,:route_group:i_group
        ,:route_descr:route_descri;
    EXEC SQL CLOSE C1A;

    display_records("R",fin_yn,c_count,norecs);

    for(i=0;i<c_count;++i )
      {
      recs[0]         = recs[0]+1;
      route_idi[i]    = -1;
      route_descri[i] = -1;
      i_group[i]      = -1;
      term_varchar(route_group[i]);
      term_varchar(route_id[i]);
      this_route=atoi((char*)route_id[i].arr);
      term_varchar(route_descr[i]);

      if (EXDebug)
        {
        printf("The value of the route is : %d\n",this_route);
        printf("%c%c%c%-20s%c%-40s%c\n",d_quote
                                       ,rec_type
                                       ,fld_sep
                                       ,(char*)route_group[i].arr
                                       ,fld_sep
                                       ,(char*)route_descr[i].arr
                                       ,d_quote);
        }

      fprintf(fp,"%c%c%c%-20s%c%-40s%c\n",d_quote
                                         ,rec_type
                                         ,fld_sep
                                         ,(char*)route_group[i].arr
                                         ,fld_sep
                                         ,(char*)route_descr[i].arr
                                         ,d_quote);

      if((status = get_s_type_records(fp)) != SUCCESS)
        {
        EXEC SQL ROLLBACK WORK;
        jobend(EXJobId,1,"get_s_type_records returned null");
        EXEC SQL COMMIT WORK;
        dblogoff();
        exit(FALSE);
        }
      }
    }

  EXEC SQL CLOSE C1;

  return(SUCCESS);

}

/* ============================================================================
 * Function: get_p_type_records
 *
 * Obtain all Road groups from the GRI_RUN_PARAMETERS table.
 *
 * For each record retrieved all associated road groups must be obtained.
 *
 * ============================================================================
 */

int get_p_type_records(fp)
FILE *fp;
{
  int norecs=0, i, fin_yn=0, c_count=0;
  /* =======================================================================
  * This cursor has been written to provide a list of all road groups for
  * the selected report parameter.
  * ======================================================================*/
  EXEC SQL DECLARE C0 CURSOR FOR
  SELECT distinct(to_number(grp_value))
    FROM gri_run_parameters
   WHERE grp_job_id = :job_id
     AND grp_param  = 'ROAD_ID'
       ;
  EXEC SQL OPEN C0;

  while(!fin_yn)
    {
    EXEC SQL FETCH C0
    INTO :road_id:i_road_id;

    fin_yn  = (sqlca.sqlcode == EOFTCH) ? 1 : 0 ;
    c_count = sqlca.sqlerrd[2] -norecs;
    norecs  = sqlca.sqlerrd[2];

    display_records("P",fin_yn,c_count,norecs);

    for(i=0;i<c_count;++i)
      {
      road_group=road_id[i];
      if(( status = get_r_type_records(fp)) != SUCCESS )
        {
        EXEC SQL ROLLBACK WORK;
        jobend(EXJobId,1,"get_r_type_records returned null");
        EXEC SQL COMMIT WORK;
        dblogoff();
        exit(FALSE);
        }
      }
    }

  EXEC SQL CLOSE C0;

  return(SUCCESS);

}


/*--------------------------------------------------------------------*/
/* Function: get_s_type_records                                       */
/*                                                                    */
/* Obtain all 'S' type records from the database for the specified    */
/* group.                                                             */
/*--------------------------------------------------------------------*/
int get_s_type_records(fp)
FILE *fp;
{
  int norecs = 0                               /* Record number       */
     ,j      = 0                               /* Record counter      */
     ,fin_yn = 0                               /*                     */
     ,c_count= 0                               /* Record count        */
    ;
  char rec_type='S';                           /* Record type         */

  if(EXDebug)
    {
    printf("The value of THIS ROUTE is : %d\n",this_route);
    }
  /*--------------------------------------------------------------------*/
  /* Obtain all sections for the select route                           */
  /*--------------------------------------------------------------------*/
  EXEC SQL DECLARE C2 CURSOR FOR
  SELECT distinct rpad(rse.rse_agency||rse.rse_linkcode,10)
        ,rse.rse_sect_no
        ,rse.rse_length
        ,substr(replace(rse.rse_descr,',',';'),1,80)
        ,rsm.rsm_seq_no
        ,rse_road_environment
        ,rse_traffic_level
        ,rse_scl_sect_class
        ,rse_road_type
        ,rse_he_id
    FROM road_segs      rse
        ,road_seg_membs rsm
   WHERE rse.rse_he_id = rsm.rsm_rse_he_id_of
     AND rse.rse_type  = 'S'
     AND rsm.rsm_rse_he_id_in = :this_route
     AND (rsm.rsm_end_date is null
         OR(rsm.rsm_start_date >= to_date(nvl(:EXParam[1],sysdate),'DD-MON-YYYY')
            AND rsm.rsm_end_date <= to_date(nvl(:EXParam[1],sysdate),'DD-MON-YYYY')))
   ORDER
      BY rsm.rsm_seq_no
        ,rse.rse_sect_no
       ;

  EXEC SQL OPEN C2;

  while(!fin_yn)
    {
    EXEC SQL FETCH C2
    INTO :sect_linkcode:sect_linkcodei
        ,:sect_sectno:sect_sectnoi
        ,:sect_length:sect_lengthi
        ,:sect_descr:sect_descri
        ,:sect_seq_no:sect_seq_noi
        ,:sect_environment:sect_environmenti
        ,:sect_traffic_level:sect_traffic_leveli
        ,:sect_class:sect_classi
        ,:sect_road_type:sect_road_typei
        ,:sect_he_id:sect_he_idi
       ;

    fin_yn = (sqlca.sqlcode == EOFTCH) ? 1 : 0;

    if((sqlca.sqlcode == EOFTCH) || (sqlca.sqlerrd[2] == 0))
      fin_yn = TRUE;

    c_count = sqlca.sqlerrd[2] -norecs;
    norecs  = sqlca.sqlerrd[2];

    display_records("S",fin_yn,c_count,norecs);

    for(j=0;j<c_count;++j)
      {
      recs[1]=recs[1]+1;
      term_varchar(sect_linkcode[j]);
      term_varchar(sect_sectno[j]);
      term_varchar(sect_length[j]);
      term_varchar(sect_descr[j]);
      term_varchar(sect_environment[j]);
      term_varchar(sect_traffic_level[j]);
      term_varchar(sect_class[j]);
      term_varchar(sect_road_type[j]);

      if(EXDebug)
        {
        printf("%c%c%c%s%c%s%c%s%c%s%c%s%c%s%c%s%c%s%c%d%c\n",d_quote
                                                             ,rec_type
                                                             ,fld_sep
                                                             ,(char*)sect_linkcode[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_sectno[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_length[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_descr[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_environment[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_traffic_level[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_class[j].arr
                                                             ,fld_sep
                                                             ,(char*)sect_road_type[j].arr
                                                             ,fld_sep
                                                             ,sect_he_id[j]
                                                             ,d_quote);
        }

      fprintf(fp,"%c%c%c%s%c%s%c%s%c%s%c%s%c%s%c%s%c%s%c%d%c\n",d_quote
                                                               ,rec_type
                                                               ,fld_sep
                                                               ,(char*)sect_linkcode[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_sectno[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_length[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_descr[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_environment[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_traffic_level[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_class[j].arr
                                                               ,fld_sep
                                                               ,(char*)sect_road_type[j].arr
                                                               ,fld_sep
                                                               ,sect_he_id[j]
                                                               ,d_quote);
      }
}

EXEC SQL CLOSE C2;

return(SUCCESS);
}

/* *************************************************************************
 * Function: get_z_type_records                                            *
 *                                                                         *
 * Obtain all 'Z' type records from the database and format them into a    *
 * buffer ready to be output to a specified datafile.                      *
 *                                                                         *
 * *********************************************************************** */

int get_z_type_records(fp)
FILE *fp;
{
    char rec_type = 'Z';
    int  i;

    recs[2]=0;
    for ( i=0;i<2;i++ )
      recs[2]=recs[2]+recs[i];

    if (EXDebug)
    {
    printf("%c%c%c%03d%c%03d%c%03d%c\n"
                               ,d_quote
                               ,rec_type
                               ,fld_sep
                               ,recs[0]
                               ,fld_sep
                               ,recs[1]
                               ,fld_sep
                               ,recs[2]
                               ,d_quote);
    }

    fprintf(fp,"%c%c%c%03d%c%03d%c%03d%c\n"
                               ,d_quote
                               ,rec_type
                               ,fld_sep
                               ,recs[0]
                               ,fld_sep
                               ,recs[1]
                               ,fld_sep
                               ,recs[2]
                               ,d_quote);
    return(SUCCESS);

}



/******************************************************************************
 * Function : open_cde_rep()                                                  *
 *                                                                            *
 *                                                                            *
 * Description : This function combines the initials of the user who isssues  *
 *               the report and a number that is derrived from the number     *
 *               of files found in the location specified by either the       *
 *               environment variable prod_fildir or by the users HOME       *
 *               environment variable. The file is suffixed with the .WIF     *
 *               ( Work Interface File ) extension.                           *
 ******************************************************************************/
FILE *open_cde_rep()
{
FILE *fp;
#ifndef IBM
FILE *fopen();
#endif

  recs[0]=0;                                 /* Initialize 'R' record counter */
  recs[1]=0;                                 /* Initialize 'S' record counter */
  recs[2]=0;                                 /* Initialize total records      */


  if ((fp=fopen(EXRepOutpath,"w")) == NULL)
  {
        write_pipe(NULL,"Unable to open output file for writing.");
        write_pipe(NULL,"File name is : ");
        write_pipe(NULL,EXRepOutpath);
        write_pipe(NULL,"Module aborted");
	sprintf(GBErrMsg,"%s %s",EXRepOutpath,strerror(errno));
        puts(GBErrMsg);
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,1,GBErrMsg);
	EXEC SQL COMMIT WORK;
	dblogoff();
	exit(FALSE);
  }

  return(fp);        /* Return file pointer of opened file */

 }

/***************************************************************************
 Function    : display_records
 Description : This function should be used to display the selected records
               for a s.elected record type.
***************************************************************************/
int display_records(r_type
                   ,f_n
                   ,c_c
                   ,n_r)
char *r_type;
int  f_n,c_c,n_r;
{

  if(EXDebug)
    {
    printf("\n%s Type Records\n",r_type);
    printf("Fin_yn : %d\n",f_n);
    printf("c_count: %d\n",c_c);
    printf("norecs : %d\n",n_r);
    }

  return(SUCCESS);

}

/* =======================================================================
 * Function : nullfill
 * Purpose  : Fill the string argument with null characters to the full
 *            length of the string.
 * =======================================================================
 */
void nullfill(char *str,int len)
{
int count;
   for (count =0 ; count < len; count++)
       str[count] = '\0';
}

void usersigfunc(sig)
int sig;
{
        write_pipe(NULL,"Abort signal received by module. Module aborted.");
	printf("Signal %d received. Aborting ...",sig);
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,1,"Signal received causing abnormal program termination");
	EXEC SQL COMMIT WORK;
}
