
/* SCCS ID keywords, do not remove */
/* static char *sccsid = "@(#)r4util.pc	1.8 12/15/06"; */
/* Copyright (c) 2013 Bentley Systems Incorporated. All rights reserved. */

/*PVCS keyword, do not remove */
static char *sccsid = "$Workfile:   r4util.pc  $ $Revision:   2.1  $ $Modtime:   Jul 02 2013 10:20:20  $";

/*
 *   CHANGE HISTORY :-
 *
 *   DATE         : 01-SEP-97                                           
 *   CHANGED BY   : Garry Fletcher                                      
 *   DESCRIPTION  : 1.7 > 2.1 Database Conversion
 *
 *   DATE         : 31-10-97
 *   CHANGED BY   : G Fletcher
 *   DESCRIPTION  : client-server conversion
*/

#include <stdio.h>
#include "rmms.h"
#include <ctype.h>
extern MAXENDCHAIN;  /* Maximum chainage value                     */
extern pipe_msg[254];

/* ==========================================================================
 * Included Function List - This is not a prototype listing.
 * --------------------------------------------------------------------------
 * a. oralogon()     : Log onto the Oracle database
 * b. oralogoff()    : Log off from the Oracle database
 * c. trace_on()     : Set TRACE on
 * c. trace_off()    : Set TRACE off 
 * d. commit()       : Commit outstanding transactions
 * e. rollback()     : Rollback outstanding transactions
 * f. oraerror()     : Display Oracle error.
 * h. nullfill()     : Fill a supplied string with space.
 * i. chkstr()       : Compare one string with another and the supplied length
 * j. get_date()     : Obtain the current date.
 * k. getargs()      : Obtain string arguments.
 * l. getstrs()      : Obtain string fields.
 * m. rmcaseup()     : Uppercase supplied character.
 * n. rmmstype()     : Check and report on the database type.
 * o. date_check()   : Check the supplied date for format and value
 * p. time_check()   : Check the supplied time for format and value.
 * q. validate_code(): Validate the supplied coda value from code array.
 * r. is_yn()                 : Checks the incoming argument for Y|N value.
 * s. get_next_doc_id(): Obtain the next document id from the document sequence
 * t. get_section()           : Obtain section details for the specified 
 * u. validate_section()      : Obtain section details for the suppplied values.
 * w. get_default_treatment() : Obtain the default repair treatment of defect
 * x. get_target_repair_date(): Obtain the repair terget repair date.
 * y. days_between()          : Obtain the days between two supplied dates.
 * z. get_due_date()          : Obtain the date due.
 * 1. Validate_job_item()     : Validate the entered standard item
 * 2. Validate_xsp()          : Validate the defect xsp value.
 * 3. get_section_descr()     : Obtain a section description. 
 * 4. get_person_admin()      : Obtain the specified persons admin unit.
 * 5. get_defect_avail()      : Obtain the initial defect availablity code
 * 6. update_sect_last_updated: Update the last inspected date for the specified
 *                              section.
 * ==========================================================================
 */ 

struct code_types
      { int       code_type;               /* Code type                    */
        char      code_value[10];          /* Code value                   */
        long  int code_code_value;         /* Secondary code value         */
      };

extern struct code_types code_values[MAXCODES];
extern struct code_types *c_ptr;
extern rmmstype();
extern short EXDebug;

EXEC SQL INCLUDE sqlext.h;


/* ==============================================================
 * SQL common declaration area for PRO*C host variables   
 * ==============================================================
 */

EXEC SQL BEGIN DECLARE SECTION;
     short int v_day_num                         /* Day number - 1..7        */
              ,v_holiday_count
              ,i_holiday_count
;
     varchar sqldate[10]                         /* Current date             */
            ,u_date[10]                          /* Current date             */
            ,u_county[40]                        /* Authority                */
            ,userid[66]                          /* Selected user id         */
            ,full_date[19]                       /* Extended date format     */
            ,v_sys_flag[2]                       /* Link/Section system flag */
            ,v_doc_title[121]                    /* Document title           */
            ,v_agency[5]                         /* Section agency           */
            ,v_linkcode[7]                       /* Section group            */
            ,v_section[6]                        /* Section number           */
            ,v_rse_unique[21]                    /* Highways element id      */
            ,v_defect_priority[5]                /* Defect priority variable */
            ,v_defect_action_cat[2]              /* Defect action cat ind    */
            ,v_defect_actcode[3]                 /* Defect activity code     */
            ,v_int_code[5]                       /* Defect interval code     */
            ,v_use_working_days[2]               /* Working days indicator fl*/
            ,v_use_next_insp[2]                  /* Next inspexction         */
            ,v_defect_code[5]                    /* Defect code              */
            ,v_defect_treatment[5]               /* Defect Repair Actcode    */
            ,v_defect_inspdate[10]               /* Defect inspection date   */
            ,v_option_value[101]                 /* System option value      */
            ,v_option_id[31]                     /* System option id         */
            ,v_start_date[12]                    /* Start date               */
            ,v_end_date[12]                      /* End date                 */
            ,v_defect_interval[5]                /* Defect interval code     */
            ,v_job_item[10]                      /* Standard item            */
            ,v_job_quantity[12]                  /* Standatd item quantity   */
            ,v_job_name[40]                      /* Standard item name       */
            ,v_xsp[2]                            /* Xsp variable             */
            ,v_inspdate[7]                       /* Inspection date          */
            ,v_item_code[3]                      /* Inv item code            */
            ,v_date[7]                           /* Date variable            */
            ,v_interval[5]                       /* Interval variable        */
            ,v_actioncat[2]                      /* Action category variable */
            ,v_priority[5]                       /* Priority variable        */
            ,v_actcode[3]                        /* Activity code variable   */
;
     long int v_rse_he_id                        /* Section identifier.      */
             ,v_length                           /* Section length.          */
             ,v_between_days                     /* Days between two dates.  */
;
     float    v_job_rate                         /* Standard item job rate   */
             ,v_job_labour                       /* Standard item labour rate*/
;
     int rmms_flag                               /* rmms flag                */
;
     long int document_id                        /* New document id          */
;
     short int i_rmms_flag                       /* rmms_flag indicator      */
              ,iu_date                           /* date indicator           */
              ,iu_county                         /* authority indicator      */
              ,i_vsys_flag                       /* Section system flag ind  */
              ,i_rse_he_id                       /* Highways element ind     */
              ,i_length                          /* Section length ind       */
              ,i_sys_flag                        /* Section sys flag ind     */
              ,i_doc_title                       /* Document title indicator */
              ,i_defect_actcode                  /* Activity code indicator  */
              ,i_use_working_days                /* Working days indicator   */
              ,i_v_int_code                      /* Interval indicator       */
              ,i_defect_treatment                /* Defect treatment ind.    */
              ,i_defect_interval                 /* Defect interval indicator*/
              ,i_option_value                    /* System option value ind. */
              ,i_between_days                    /* Days between indicator   */
              ,i_end_date                        /* End date indicator       */
              ,i_use_next_insp                   /* Next inspection indicator*/
              ,i_job_name                        /* Standard item job name   */
              ,i_job_rate                        /* Standard item rate       */
              ,i_job_labour                      /* Standard item labour unit*/
              ,i_exists                          /* Existance indicator      */
              ,i_xsp                             /* Xsp indicator            */
              ,i_inspdate                        /* Inspection date indicator*/
              ,i_item_code                       /* Item code indicator      */
              ,v_exists                          /* Existance variable       */
;
EXEC SQL END DECLARE SECTION;


/* ================================================================
 * Function Declaration area     
 * ================================================================
 */

char date[10]                              /* Current date field */
    ,county[40]                            /* Authority          */
;

/* ========================================================================
 * Function : trace_on
 * Purpose  : To enable the program to turn tracing on
 * ========================================================================
 */   
BOOLEAN trace_on()
{

EXEC SQL ALTER SESSION SET SQL_TRACE = TRUE; 

oraerror("TRACE_ON");

}

/* ========================================================================
 * Function : trace_off
 * Purpose  : To enable the program to turn tracing on
 * ========================================================================
 */   
BOOLEAN trace_off()
{

EXEC SQL ALTER SESSION SET SQL_TRACE = FALSE; 

oraerror("TRACE_OFF");

}

/* ===========================================================================
 * Function : commit() 
 * Purpose  : Commit any outgstanding transactions to the database. 
 * ===========================================================================
 */
void commit()
{ 
EXEC SQL COMMIT WORK;
return;
}

/* ===========================================================================
 * Function : rollback() 
 * Purpose  : Rollback any outstanding transactions from the database. 
 * ===========================================================================
 */
void rollback()
{ 
EXEC SQL ROLLBACK WORK;
return;
}

/* ===========================================================================
 * Function : oraerror()
 * Purpose  : Detects and outputs a oracle error to standard output
 *     
 * ===========================================================================
 */
BOOLEAN oraerror(fname)
char *fname;
{                                                          
int recno;                                                 
char temp[10];

    recno = getseqno();
   if (sqlca.sqlcode < 0)
   {
/*
      printf(
"\nINFO:\n%s\nError occured in function : %s\nRecord Number : %d BPR-8202\n",
      sqlca.sqlerrm.sqlerrmc,
      fname,
      recno);
      write_pipe(NULL,"INFO: ");
      write_pipe(NULL,sqlca.sqlerrm.sqlerrmc);
      strcpy(pipe_msg," Error occured in function : ");
      strcat(pipe_msg,fname);
      write_pipe(NULL,pipe_msg);
      i_toa(recno,temp);
      strcpy(pipe_msg,"Record Number : ");
      strcat(pipe_msg,temp);
      strcat(pipe_msg," BPR-8202");
      write_pipe(NULL,pipe_msg);
*/
      strcpy(pipe_msg,fname);
      strcat(pipe_msg," (Record Number ");
      i_toa(recno,temp);
      strcat(pipe_msg,temp);
      strcat(pipe_msg,")");

      sql_err(pipe_msg);
   }
   else
      return(FAIL);
}

/* =======================================================================
 * Function : nullfill
 * Purpose  : Fill the string argument with null characters to the full
 *            length of the string.
 * =======================================================================
 */
void nullfill(str,len)
char *str;
int  len;
{
int count;
   for (count =0 ; count < len; count++)
       str[count] = '\0';
}

BOOLEAN chkstr(str1,str2,chklen)
char *str1,*str2;
int chklen;
{
int i;
   for (i=0;(*(str1+i) == *(str2+i)) && (i < chklen);i++) ;
   if (i == chklen)
      return(SUCCESS);
   else
      return(FAIL);
}

/* =======================================================================
 * Function : get_date 
 * Purpose  : Obtain the current date. 
 * =======================================================================
 */
BOOLEAN get_date(date)
char date[10];
{
   EXEC SQL SELECT SYSDATE, to_char(sysdate,'DD-MON-RR:HH24:MI:SS')
            INTO :sqldate, :full_date
            FROM dual;
   if (oraerror("GETDATE")) return(FAIL);
   *(sqldate.arr + sqldate.len) = '\0';
   strcpy(date,sqldate.arr);
   return(SUCCESS);
}


/* ===========================================================================
 * Function : getargs()                               
 * Purpose  : GETARGS: To get character and string arguments separated by commas
 *            from an input string given a format. This routine deals with
 *            blanks between commas OK (unlike sscanf). Example:
 * 
 *           char *line="22,,text line, ABCD"
 *           char a1[10],a2[10];
 *           int  i1,i2,noargs;
 *
 *           then: noargs = getargs("ddss",line,i1,i2,a1,a2)
 *           returns: i1 as 22,
 *           i2 as 0,
 *           a1 as "text line",
 *           a2 as " ABCD"
 *           noargs as 4.
 *
 *       GETSTRS: to get the addresses of arguments in a string separated by
 *                commas.
 *
 * Calling Sequence:
 *         getargs(format,string,a1,a2,a3,a4,....);
 *
 *         getstrs( string,args )
 * Input:   char *format   A string specifying the argument types expected,
 *                       d indicates int, s indicates string.
 *
 *        char *string   String containing arguments separated by commas,
 *                            a ",," for a string returns a zero length
 *                        string.
 *
 *         char *a1...    array to put output sting in
 *        or
 *       int  &a1,...   addresses of integer variables to put args in.
 *
 * Output:  int  getargs   No. of arguments found, this will be a max of
 *                         strlen(format) and less if fewer arguments found.
 *
 *         int getstrs    No. of arguments found.
 * 
 *       char *args[ ]  array containing addresses of each of the arguments
 *                      found.
 *
 * Notes:   Results will be unpredictable if fewer output variables are
 *          provided in the call than required by format.
 *
 *          MAXIMUM of 15 arguments ( ai's.)
 * 
 * Author:  Alan Goddard 5 May 88
 * ============================================================================
 * Changes:
 * MODIFIED BY: Steve Voller
 * REASON     : Porting problem with the union iors line. DRS6000 dumps
 *              the core at this point therfore #ifdef introduced.
 * DATE       : 14-SEP-91
 * ============================================================================
 */
getargs( char *format
	,char *line
	,void *a1
	,void *a2
	,void *a3
	,void *a4
	,void *a5
	,void *a6
	,void *a7
	,void *a8
	,void *a9
	,void *a10
	,void *a11
	,void *a12
	,void *a13
	,void *a14
	,void *a15 )
{ char *args[15];
   int getstrs(),nf,noargs;
   int i;   
noargs = getstrs(line,args);      /* get arg addresses into args[] */

nf =  strlen(format);
nf = (nf<noargs) ? nf:noargs;
format += nf-1;
switch (nf) {
    case 15: if (*format-- == 'd')  *(int *)a15 = atoi(args[14]);
            else                   strcpy((char *)a15,args[14]);
    case 14: if (*format-- == 'd')  *(int *)a14 = atoi(args[13]);
            else                   strcpy((char *)a14,args[13]);
    case 13: if (*format-- == 'd')  *(int *)a13 = atoi(args[12]);
            else                   strcpy((char *)a13,args[12]);
    case 12: if (*format-- == 'd')  *(int *)a12 = atoi(args[11]);
            else                   strcpy((char *)a12,args[11]);
    case 11: if (*format-- == 'd')  *(int *)a11 = atoi(args[10]);
            else                   strcpy((char *)a11,args[10]);
    case 10: if (*format-- == 'd')  *(int *)a10 = atoi(args[9]);
            else                   strcpy((char *)a10,args[9]);
    case  9: if (*format-- == 'd')  *(int *)a9 = atoi(args[8]);
            else                   strcpy((char *)a9,args[8]);
    case  8: if (*format-- == 'd')  *(int *)a8 = atoi(args[7]);
            else                   strcpy((char *)a8,args[7]);
    case  7: if (*format-- == 'd')  *(int *)a7 = atoi(args[6]);
            else                   strcpy((char *)a7,args[6]);
    case  6: if (*format-- == 'd')  *(int *)a6 = atoi(args[5]);
            else                   strcpy((char *)a6,args[5]);
    case  5: if (*format-- == 'd')  *(int *)a5 = atoi(args[4]);
            else                   strcpy((char *)a5,args[4]);
    case  4: if (*format-- == 'd')  *(int *)a4 = atoi(args[3]);
            else                   strcpy((char *)a4,args[3]);
    case  3: if (*format-- == 'd')  *(int *)a3 = atoi(args[2]);
            else                   strcpy((char *)a3,args[2]);
    case  2: if( *format-- == 'd')  *(int *)a2 = atoi(args[1]);
            else                   strcpy((char *)a2,args[1]);
    case  1: if( *format   == 'd')  *(int *)a1 = atoi(args[0]);
            else                   strcpy((char *)a1,args[0]);
    }

  return(noargs);
}
/* ===========================================================================
 * Function : getstrs
 * Purpose  : returns the no of strings found (seperator = ',') in line
 *
 * input line
 *
 * output args - array of char pointers to line
 *
 * effects truncates line by inserting a 0 at pos of first comma
 * ===========================================================================
 */
int getstrs( char *line, char *args[] )
{ 
    int  noargs=0 /* Number of arguments */
        ,i        /* Variable counter    */
        ,j        /* Variable counter    */
;
    char *strchr()
        ,*l;      /* String pointer      */

    while( line!= NULL && *line != '\0' ) 
    {
       args[noargs++]=line;
       line=strchr(line,',');
       if( line != NULL ) *line++ = '\0';
    }

    for(i=0;i<noargs;i++)                       /* Take off training spaces  */
    {
      for(l=args[i],l+=strlen(l)-1;*l==' ';*l-- = '\0');
      l=args[i];
      while (*(l)==' ') l++;                    /* Remove all leading spaces */
      args[i]=l;
    }

return(noargs);

}

/* ============================================================================
 * Function :  rmcaseup
 * Purpose  : To obtain the uppercase of a passed character parameter.  
 * ============================================================================
 */
int rmcaseup(character)
int character;
{
     if ((character >= 'A' && character <= 'Z') || character == '1')
           return(character);
     else
           return(character - 'a' + 'A');
}

/* ============================================================================
 * Function : rmms_type()
 * Purpose  : Obtain the type of highways database installed and obtain the
 *            maintaining organisation and display the database type.
 * ============================================================================
 */
int rmmstype(date,county)
char *date
    ,*county
;
{
static int rmms_type = 0;


EXEC SQL WHENEVER SQLERROR CONTINUE;

if (rmms_type == 0)
{
EXEC SQL SELECT HAU_NAME
         INTO   :u_county:iu_county
         FROM   HIG_ADMIN_UNITS
		 WHERE  HAU_LEVEL = 1;

   term_varchar(u_county);

EXEC SQL SELECT to_number(HOP_VALUE),
                TO_CHAR(sysdate,'RR-MON-DD')         
         INTO   :rmms_flag:i_rmms_flag,
                :u_date:iu_date
         FROM    HIG_OPTIONS
		 WHERE   HOP_ID='RMMSFLAG'
		 AND     HOP_PRODUCT='HIG';


   term_varchar(u_date);

if ((sqlca.sqlcode < 0) 
   || (sqlca.sqlcode == 1403) 
   || (i_rmms_flag == -1)
   || (rmms_flag == 0))
rmms_type = 1;     
else
rmms_type = rmms_flag;

  switch  (rmms_type)
  {
     case 1 : printf("\nDatabase type is : Oracle DTp Standard\n\n");
              write_pipe(NULL,"Database type is : Oracle DTp Standard");
              break;

     case 2 : printf("\nDatabase type is : Hims/Oracle Hybrid\n\n");
              write_pipe(NULL,"Database type is : Hims/Oracle Hybrid");
              break;

     case 3 : printf("\nDatabase type is : Maintenance Manager\n\n");
              write_pipe(NULL,"Database type is : Maintenance Manager");
              break;    

     case 4 : printf("\nDatabase type is : Welsh Office Standard\n\n");
              write_pipe(NULL,"Database type is : Welsh Office Standard");
              break;
               
     default : printf("\nDatabase type is : Unknown\n");
               printf("Oracle Dtp standard assumed\n\n");
               write_pipe(NULL,"Database type is : Unknown");
               write_pipe(NULL,"Oracle Dtp standard assumed");
               rmms_type=1;
               break;    
   }
EXEC SQL WHENEVER SQLERROR do sql_err("rmmstype(1)");
return(rmms_type);
}
else
 {
  EXEC SQL WHENEVER SQLERROR do sql_err("rmmstype(2)");
  strcpy(county,u_county.arr);
  strcpy(date,u_date.arr); 
  return(rmms_type);
 }
}


/*
 *======================================================================
 * 
 * Function : date_check
 *
 * Check the date.
 *
 * Return  1 if good -1 otherwise
 *         reformatted date as second argument.
 *
 *======================================================================
 */
int date_check (ip_date)
char *ip_date;
{
	char	tmp_arr[6];
	int	day_ofset = 4;
	int day_len   = 2;
	int	mon_ofset = 2;
	int mon_len   = 2;
	int	yr_ofset  = 0;
	int yr_len    = 2;
	int	mon;
	int	dy;
	int	yr;
	int ret_val   = 1;
	int lp_yr     = 0;

	/*
	 *================================================================
	 * Assumed input format = YYMMDD if not further processing will 
	 * be required
	 *================================================================
	 */


	/*
	 *================================================================
	 * Extract the day
	 *================================================================
	 */

	strncpy (tmp_arr,ip_date + day_ofset,day_len);
	tmp_arr[day_len] = '\0';
	dy = atoi(tmp_arr);
	
	/*
	 *================================================================
	 * Extract the Month
	 *================================================================
	 */

	strncpy (tmp_arr,ip_date + mon_ofset,mon_len);
	tmp_arr[mon_len] = '\0';
	mon = atoi(tmp_arr);
	
	/*
	 *================================================================
	 *
	 * Extract the year
	 * Prefix the century if required. Assumption made is that if the 
	 * year is less than 70 the we have wrapped to the 21st century
	 *
	 *================================================================
	 */

	strncpy (tmp_arr,ip_date + yr_ofset,yr_len);
	tmp_arr[yr_len] = '\0';
	yr = atoi(tmp_arr);
	
	if (yr < 70)
	{
		yr = 2000 + yr;
	}
	else
	{
		yr = 1900 + yr;
	}
	
	/*
	 *===================================================================
	 * Check for leap year.
	 *
	 * Algorithm used to determine if this is a leap year is that
	 * the year is divisible by 4 without a remainder but not divisible
	 * by 400. OR YEAR IS 2000
	 * 
	 *===================================================================
	 */

	if ( ((((yr/4) * 4) == yr) && (((yr/400) * 400) != yr)) || (yr == 2000))
	{
		lp_yr = 1;
	}

	/*
	 *===================================================================
	 * Check the months and days.
	 *===================================================================
	 */

	switch (mon)
	{
		case 1:
		case 3:
		case 5:
		case 7:
		case 8:
		case 10:
		case 12:
			if ((dy < 1) || (dy > 31))
			{
				ret_val = -1;
			}
			break;

		case 2:
			if (lp_yr == 1)
			{
				if ((dy < 1) || (dy > 29))
				{
					ret_val = -1;
				}
			}
			else
			{
				if ((dy < 1) || (dy > 28))
				{
					ret_val = -1;
				}
			}
			break;

		case 4:
		case 6:
		case 9:
		case 11:
			if ((dy < 1) || (dy > 30))
			{
				ret_val = -1;
			}
			break;

		default:
			ret_val = -1;
			break;
	}

	return (ret_val);
}

/*
 *======================================================================
 * 
 * Function : time_check
 *
 * Check the time.
 *
 * Return  1 if good -1 otherwise
 *         
 *
 *======================================================================
 */
int time_check (ip_time)
char *ip_time;
{
	char	tmp_arr[4];
	int	    hrs_ofset  = 0;
	int     hrs_len    = 2;
	int	    min_ofset  = 2;
	int     min_len    = 2;
	int	    min;
	int	    hrs;
	int     ret_val    = 1;
            int        i;
	/*
	 *================================================================
	 * Assumed input format = HHMM if not further processing will 
	 * be required
     * Check that the time is all digits
     * ===============================================================
     */

             if ( strlen(ip_time) != 4 )
                 ret_val=-1;
             else
               for (i=0;i<strlen(ip_time);i++)
                  if (!isdigit((*ip_time+i)))
                      ret_val=-1;
            
	/*
	 *================================================================
	 * Extract the hours
	 *================================================================
	 */

	         strncpy (tmp_arr,ip_time + hrs_ofset,hrs_len);
	         tmp_arr[hrs_len] = '\0';
	         hrs = atoi(tmp_arr);
      
            if ( (hrs<0) || (hrs>23))	
               ret_val=-1;

      	/*
	 *================================================================
	 * Extract the minutes
	 *================================================================
	 */

            strncpy (tmp_arr,ip_time + min_ofset,min_len);
	        tmp_arr[min_len] = '\0';
	        min = atoi(tmp_arr);
       
            if ( (min<0) || (min>59))	
               ret_val=-1;

            if ((hrs==0) && (min==0))
                 ret_val=-1;

	return (ret_val);
}

/*
************************************************************************
* Function to check that the inspection date and time are in the past  *
* Assumes Date format is RRMMDD and Time format is HH24MI              *
************************************************************************
*/
int check_datetime(ip_date,ip_time)
char *ip_date;
char *ip_time;
  {
  int  ret_val;
  char msg[100];

  EXEC SQL BEGIN DECLARE SECTION;
  VARCHAR tmp_datetime[12];
  int     dummy=0;
  EXEC SQL END DECLARE SECTION;

  EXEC SQL DECLARE chk_sysdate CURSOR FOR
  SELECT 1
    FROM DUAL
   WHERE sysdate > to_date(:tmp_datetime,'RRMMDDHH24MI')
       ;
   
  strcpy((char*)tmp_datetime.arr,ip_date);
  strcat((char*)tmp_datetime.arr,ip_time);
  tmp_datetime.len=strlen(ip_date)+strlen(ip_time);
  tmp_datetime.arr[tmp_datetime.len]='\0';
  
  EXEC SQL OPEN  chk_sysdate;
  EXEC SQL FETCH chk_sysdate
            INTO :dummy;
  EXEC SQL CLOSE chk_sysdate;

  ret_val = dummy;

  return(ret_val);
  
  } /* check_datetime */

 /*
  *===========================================================================
  * This function should be used to validate a passssed value against a code
  * type as defined within the codes array.
  *===========================================================================
  */
BOOLEAN validate_code(c_type, c_value, cc_value)
int      c_type;
char     c_value[20];
long int *cc_value;
{
    int    ret_val=-1;
    int    i=0;

    c_ptr= &code_values[0];

    if (EXDebug && CODES)
    {
       printf("The code Type is : %d\n",c_type);
       printf("The Code is      : %s\n",c_value);
    }

    while (1) 
    {
      if ((c_ptr->code_type==c_type ) && (strcmp(c_ptr->code_value,c_value)==0))
      {
         *cc_value=c_ptr->code_code_value;
         ret_val=1;
         break;
      }
      else
      {
         *c_ptr++;
         i++;
      }

      if (( i==MAXCODES ) || ( c_ptr->code_type==0))
         break;

     }

     if (EXDebug && CODES)
     {
       puts("");
       puts("Code Type  Code Value.......... Code Code...........");           
       puts("----------------------------------------------------");
  
       printf("%-10d  %-20s %20d\n",c_ptr->code_type
                                   ,c_ptr->code_value
                                   ,c_ptr->code_code_value
                                   );
     }
     return(ret_val);
}

/* ========================================================================
 * Function : is_yn()
 * Purpose  : This function shhould check the value of the incoming       
 *            parameter for the value 'Y' or 'N'
 * Return   : BOOLEAN
 * ========================================================================
 */
BOOLEAN is_yn( v_yn )
char *v_yn;
{
  if ((rmcaseup(*v_yn)=='Y' ) || ( rmcaseup(*v_yn)=='N' ))
    return(SUCCESS);
  else
    return(FAIL);
}

/* =========================================================================
 * Function : get_next_doc_id
 * Purpose  : To obtain the next document identification value from the 
 *            document sequence. 
 * =========================================================================
 */
              
int get_next_doc_id(doc_id)
long int *doc_id;
{
      EXEC SQL 
      SELECT doc_id_seq.nextval into :document_id FROM dual;

      if (oraerror("PROSREC")) 
          return(FAIL);
      else
      {
          *doc_id=document_id;
          return(SUCCESS);
      }
}

/* =========================================================================
 * Function : validate_defect_priority() 
 * Purpose  : This function should check that the forwarded defect activity, 
 *            category and priority exists.  
 *            The function should return the default treatment code and the
 *            indicator flags which  indicate wether the procedure should 
 *            use working days or next in,spection values.
 * =========================================================================
 */

int validate_defect_priority( defect_activity      /* Activity code    [In]   */
                             ,defect_action_cat    /* Action category  [In]   */
                             ,defect_priority      /* Defect priority  [In]   */
                             ,defect_interval      /* Defect treatment [Out]  */
                             ,use_working_days     /* Use working days [Out]  */
                             ,use_next_insp)       /* Use next inspection[Out]*/

char defect_activity[3]                            /* Defect activity         */
    ,defect_action_cat[2]                          /* Defect action category  */
    ,defect_priority[5]                            /* Defect priority         */
    ,defect_interval[5]                            /* Defect interval code    */
    ,use_working_days[2]                           /* Use working day values  */
    ,use_next_insp[2]                              /* Use next inspection days*/
;
{

   strcpy(v_defect_actcode.arr   ,defect_activity);
   strcpy(v_defect_action_cat.arr,defect_action_cat);
   strcpy(v_defect_priority.arr  ,defect_priority);

   slen_varchar(v_defect_actcode);
   term_varchar(v_defect_actcode);
   slen_varchar(v_defect_action_cat);
   term_varchar(v_defect_action_cat);
   slen_varchar(v_defect_priority);
   term_varchar(v_defect_priority);
 
   EXEC SQL WHENEVER SQLERROR   GOTO rec_err;
   EXEC SQL WHENEVER SQLWARNING GOTO rec_err;
   EXEC SQL WHENEVER NOT FOUND  GOTO rec_err;

   EXEC SQL SELECT dpr_int_code
                  ,dpr_use_working_days 
                  ,dpr_use_next_insp
            INTO   :v_int_code:i_v_int_code
                  ,:v_use_working_days:i_use_working_days
                  ,:v_use_next_insp:i_use_next_insp
            FROM   defect_priorities
            WHERE  dpr_atv_acty_area_code = :v_defect_actcode
            AND    dpr_priority           = :v_defect_priority
            AND    dpr_action_cat         = :v_defect_action_cat;

   slen_varchar(v_int_code);
   term_varchar(v_int_code);
   slen_varchar(v_use_working_days);
   term_varchar(v_use_working_days);
   slen_varchar(v_use_next_insp);
   term_varchar(v_use_next_insp);

   strcpy(defect_interval,v_int_code.arr);
   strcpy(use_working_days,v_use_working_days.arr);
   strcpy(use_next_insp,v_use_next_insp.arr);

   EXEC SQL WHENEVER SQLERROR do sql_err("validate_defect_priority(1)");
   if (!ORANOREC)
     return(SUCCESS);
   else
     return(FAIL); 

  rec_err:
      EXEC SQL WHENEVER SQLERROR do sql_err("validate_defect_priority(2)");
      return(FAIL);
} 

/* ============================================================================
 * Function : validate_section()
 * Purpose  : This function should ensure that a specified section exists.
 *            The function should return the section identifier and the section
 *            length together with the section flag indicator.
 * ============================================================================
 */
int validate_section(agency, linkcode, section ,rse_he_id 
                    ,rse_length ,responsible,doc_title,rse_sys_flag)
char agency[4] 
    ,linkcode[6]
    ,section[5]
    ,doc_title[61]
;
long int *rse_he_id
        ,*rse_length
        ,*responsible
;
char     *rse_sys_flag[1];
{                     
  EXEC SQL BEGIN DECLARE SECTION;
    long int v_maxendchain
            ,v_responsible
            ,he_id=0
           ;
  EXEC SQL END DECLARE SECTION;

  int norecs=0;
  char tmp_msg[100];   

  v_maxendchain=MAXENDCHAIN;

  /*
  || If The File Is ENHANCED It May Well Contain The rse_he_id 
  || In Which Case It Will Have Been Passed In So Use It To Get
  || The Section Details.
  */
  if(*rse_he_id>0)
    {
    he_id = *rse_he_id;

    EXEC SQL SELECT rse_he_id 
                   ,nvl(nvl(rse_length,rse_max_chain),:v_maxendchain)
                   ,upper(substr(rse_unique||' '||rse_descr,1,60))
                   ,rse_admin_unit
                   ,rse_sys_flag
               INTO :v_rse_he_id:i_rse_he_id
                   ,:v_length:i_length
                   ,:v_doc_title:i_doc_title
                   ,:v_responsible
                   ,:v_sys_flag:i_vsys_flag
               FROM road_sections
              WHERE rse_he_id = :he_id
                  ;
    if(ORANOREC)
      {
      printf("rse_he_id failed\n");
      he_id = -1;
      }
    else
      {
      printf("rse_he_id validated\n");
      }
    }
  /*
  || If The Select Based On The rse_he_id Passed In Failed
  || To Return A Row Or No rse_he_id Was Passed In Use The
  || Agency Code, Linkcode And Section Number To Validate
  || The Section.
  */
  if(he_id<=0)
    {
    strcpy(v_agency.arr,agency);
    slen_varchar(v_agency);
    term_varchar(v_agency);
    
    strcpy(v_linkcode.arr,linkcode);
    slen_varchar(v_linkcode);
    term_varchar(v_linkcode);
    
    strcpy(v_section.arr,section);
    slen_varchar(v_section);
    term_varchar(v_section);
    
    EXEC SQL WHENEVER SQLERROR   GOTO rec_err;
    EXEC SQL WHENEVER SQLWARNING GOTO rec_err;
    EXEC SQL WHENEVER NOT FOUND  CONTINUE; 

    switch(rmmstype(date,county))
      { 
      case 3  : EXEC SQL SELECT rse_he_id 
                               ,nvl(nvl(rse_length,rse_max_chain),:v_maxendchain)
                               ,upper(substr(rse_unique||' '||rse_descr,1,60))
                               ,rse_admin_unit
                               ,rse_sys_flag
                          INTO :v_rse_he_id:i_rse_he_id
                              ,:v_length:i_length
                              ,:v_doc_title:i_doc_title
                              ,:v_responsible
                              ,:v_sys_flag:i_vsys_flag
                          FROM road_sections
                         WHERE rse_agency   = :v_agency
                           AND rse_linkcode = :v_linkcode
                           AND (rse_sect_no = :v_section OR rse_sect_no = substr(:v_section,4,2));
                break;
      case 4  : EXEC SQL SELECT rse_he_id 
                               ,nvl(nvl(rse_length,rse_max_chain),:v_maxendchain)
                               ,upper(substr(rse_unique||' '||rse_descr,1,60))
                               ,rse_admin_unit
                               ,rse_sys_flag
                         INTO  :v_rse_he_id:i_rse_he_id
                              ,:v_length:i_length 
                              ,:v_doc_title:i_doc_title
                              ,:v_responsible
                              ,:v_sys_flag:i_vsys_flag
                         FROM   road_sections
                         WHERE  rse_group   = :v_linkcode
                         AND  ( rse_sect_no = :v_section
                         OR     rse_sect_no = substr(:v_section,4,2));
                
                break;
      default : EXEC SQL SELECT rse_he_id 
                               ,nvl(nvl(rse_length,rse_max_chain),:v_maxendchain)
                               ,upper(substr(rse_unique||' '||rse_descr,1,60))
                               ,rse_admin_unit
                               ,rse_sys_flag
                         INTO  :v_rse_he_id:i_rse_he_id
                              ,:v_length:i_length 
                              ,:v_doc_title:i_doc_title
                              ,:v_responsible
                              ,:v_sys_flag:i_vsys_flag
                         FROM   road_sections
                         WHERE  rse_agency   = :v_agency
                         AND    rse_linkcode = :v_linkcode
                         AND    rse_sect_no  = :v_section;
                break;
      } 
    if(ORANOREC)
      {
      printf("agency, linkcode, section number failed\n");
      he_id = -1;
      }
    else
      {
      printf("agency, linkcode, section number validated\n");
      }
    }

  EXEC SQL WHENEVER SQLERROR do sql_err("validate_section(1)");

  *rse_length=v_length;
  *rse_he_id=v_rse_he_id;
  slen_varchar(v_sys_flag);
  term_varchar(v_sys_flag);
  strcpy(rse_sys_flag,v_sys_flag.arr);
  slen_varchar(v_doc_title);
  term_varchar(v_doc_title);
  strcpy(doc_title,v_doc_title.arr);
  *responsible=v_responsible;

  if(he_id != -1)
    {
    return(SUCCESS);
    }
  else
    {  
    return(FAIL);
    }

rec_err:
  EXEC SQL WHENEVER SQLERROR do sql_err("validate_section(2)");
  return(FAIL);
}

/* ===========================================================================
 * Function : get_default_treatment() 
 * Purpose  : This function should obtain the default treatment code for
 *            the supplied defect,activity and inspection date. 
 *            The function should return the default treatment code.
 * ===========================================================================
 */
int get_default_treatment( defect_code         /* Defect code          [In] */
                          ,defect_activity     /* Defect activity code [In] */
                          ,inspection_date     /* Inspection date      [In] */
                          ,default_treatment   /* Default treatment    [Out]*/
                         )
 char defect_code[5]
     ,defect_activity[3]
     ,inspection_date[12]
     ,default_treatment[5]
;
{

    strcpy(v_defect_code.arr    ,defect_code);
    strcpy(v_defect_actcode.arr ,defect_activity);
    strcpy(v_defect_inspdate.arr,inspection_date);
    slen_varchar(v_defect_code);
    term_varchar(v_defect_code);
    slen_varchar(v_defect_actcode);
    term_varchar(v_defect_actcode);
    slen_varchar(v_defect_inspdate);
    term_varchar(v_defect_inspdate);
    
    if (EXDebug)
    {
       printf("Defect code : %s\n",v_defect_code.arr);
       printf("Activity    : %s\n",v_defect_actcode.arr);
       printf("Inspdate    : %s\n",v_defect_inspdate.arr); 
    }

     EXEC SQL SELECT dtr_tre_treat_code
          INTO   :v_defect_treatment:i_defect_treatment
          FROM   def_treats  
                ,treatments  
          WHERE  dtr_dty_acty_area_code = :v_defect_actcode
          AND    dtr_dty_defect_code    = :v_defect_code
          AND    dtr_tre_treat_code     = tre_treat_code
          AND    nvl(to_date(:v_defect_inspdate,'RRMMDD'),sysdate)
          BETWEEN nvl(tre_start_date,to_date(:v_defect_inspdate,'RRMMDD'))
          AND     nvl(tre_end_date  ,to_date(:v_defect_inspdate,'RRMMDD'));

       if (ORANOREC)
          return(FAIL);

       slen_varchar(v_defect_treatment);
       term_varchar(v_defect_treatment);

       strcpy(default_treatment,v_defect_treatment.arr);
       return(SUCCESS);
    
       rec_err:
           return(FAIL);
}


/* ===========================================================================
 * Function : days_between() 
 * Purpose  : This function should obtain the number of days within a 
 *            specified date range or period. 
 * Params   : Start date End date in YYMMDD (format important)
 * ===========================================================================
 */
int days_between(start_date
                ,end_date)
char start_date[6]               /* Passed start date parameter     */
    ,end_date[6]                 /* Passed end date parameter       */
;
{
  BOOLEAN l_year =FALSE          /* Leap year indicator.            */
;
  char tmp_date[6]               /* Temporary date variable         */
      ,tmp_arr[2]                /* Temporary argument variable     */
      ,*p_date                   /* Date value pointer              */
;
  long int s_days=0              /* Sum of start days               */
          ,e_days=0              /* Sum of end days                 */
          ,t_days=0              /* Total days variable             */
;
   int ofset                     /* Data field offset position      */
      ,len   = 2                 /* Data variable length            */
      ,t_val = 0                 /* Temporary value variable        */
      ,t_mon                     /* Temporary month value           */
      ,t_yr                      /* Temporay year value.            */
      ,i,j                       /* General integer variables       */
      ,s_day                     /* Start day value variable        */
      ,s_mon                     /* Start month value variable      */
      ,s_yr                      /* Start year value variable       */
      ,e_day                     /* End day value variable          */
      ,e_mon                     /* End month value variable        */
      ,e_yr                      /* End year value variable         */
      ,lp_yrs                    /* Number of leap years.           */
      ,yr_days                   /* Number of days in years         */
      ,n_lp_yrs                  /* Number of leap years            */
      ,mon_days[11];             /* Days of the month array         */

/* =========================================================================
 * The following code has been moved to this position due to porting
 * problems.
 * =========================================================================
 */

      mon_days[0]=31;            /* Days in January                 */
      mon_days[1]=28;            /* Days in February                */
      mon_days[2]=31;            /* Days in March                   */
      mon_days[3]=30;            /* Days in April                   */
      mon_days[4]=31;            /* Days in May                     */
      mon_days[5]=30;            /* Days in June                    */
      mon_days[6]=31;            /* Days in July                    */
      mon_days[7]=31;            /* Days in August                  */
      mon_days[8]=30;            /* Days in September               */
      mon_days[9]=31;            /* Days in October                 */
      mon_days[10]=30;           /* Days in November                */
      mon_days[31]=31;           /* Days in December                */

/* ===========================================================================
 * Assumes that the dates are in the format yymmdd.
 * ===========================================================================
 */
     for (j=0;j<=1;j++)
     {
        ofset=0;
        if (j==0)
           strcpy(tmp_date,start_date);
        else
           strcpy(tmp_date,end_date);

        if (strlen(tmp_date)!=6)
        {
             printf("Specified date has incorrect format.\n");
             write_pipe(NULL,"Specified date has incorrect format.");
        }

        p_date= &tmp_date[0];

        for (i=0;i<3;i++)
        {
           strncpy(tmp_arr,p_date+ofset,len);
           tmp_arr[len]='\0'; 
           t_val=atoi(tmp_arr);
           switch (j)
           {
            case  0: if (i==0) s_day=t_val;
                     if (i==1) s_mon=t_val;
                     if (i==2) s_yr =t_val;
                     break;
            case  1: if (i==0) e_day=t_val;
                     if (i==1) e_mon=t_val;
                     if (i==2) e_yr =t_val;
                     break;
           }
          ofset=ofset+2;
        }
      }

      for (j=0;j<2;j++)
      {
        l_year=FALSE;                              /* Set leap year indicator*/
        t_days=0;                                  /* to null and total days */
        switch (j)                                 /* to zero.               */
        {
            case 0:
                    t_yr = s_yr;                   /* Set temp yr to start yr */
                    break;
            case 1:
                    t_yr = e_yr;                   /* Set temp yr to end yr*/ 
                    break;
        }
   
        if (s_yr!=e_yr)                             /* If the years are not */
        {                                           /* the same.            */
           if ( t_yr < 70 )                         /* Attempt to locate the*/
              t_yr=2000 + t_yr;                     /* correct century.     */
           else 
              t_yr=1900 + t_yr;                     /* Specify 1900 century */

      if ((((t_yr/4)*4)==t_yr) && 
         (((t_yr/400)*400)!=t_yr))                  /* Test for leap year.  */
           l_year =TRUE;                            /* Leap year detected   */

         lp_yrs    = t_yr/4;                        /* Number of leap years */
         n_lp_yrs  = t_yr - lp_yrs;                 /* Non leap years       */
         yr_days   = ( n_lp_yrs * 365 ) +           /* Non leap year days   */
                     ( lp_yrs   * 366 );            /* Leap year days       */
         if (j==0)                                  
             s_days=yr_days;                        /* Set start days value */
         else
             e_days=yr_days;                        /* Set start days value */

      }

      if ( s_mon != e_mon )                         /* If the start and end */
      {                                             /* months are not the   */
          switch (j)
          {
             case 0: t_mon=s_mon;
                     break;
             case 1: t_mon=e_mon;
                     break;
          }
 
          for (i=0;i<(t_mon-1);i++)                 /* same .               */
            t_days=t_days+mon_days[i];
          if (l_year) t_days++;                     /* Add an extra day for */
          yr_days=yr_days+t_days;
      }                                             /* a leap year.         */
      
      switch (j)                                    /* For the start and end */
      {                                             /* days.                 */
          case 0: t_days=t_days+s_day;              /* Obtain start days     */
                  s_days=s_days+t_days;             /* Sum start year days   */
                  break;                            /* + total start days    */
          case 1: t_days=t_days+e_day;              /* Obtain end days       */
                  e_days=e_days+t_days;             /* Sum year days + total */
                  break;                            /* end days              */
      }
   }
}


/* ===========================================================================
 * Function : get_due_date() 
 * Purpose  : This function should provide the calling function with a target
 *            repair date. 
 * Params   : The function should make use of a database package named
 *            target_repair_date.pck
 *
 *            The procedures that are maintained within the package are as
 *            follows : target_repair_date.rep_date_due
 *                      target_repair_date.date_due
 *                      terget_repair_date.we_in_period
 *                      target_repair_date.work_days  
 *
 * ===========================================================================
 */

int get_due_date( seqid                         /* Error sequence id        */
                 ,inspdate                      /* Incoming inspection date */
                 ,activity_area                 /* Inspection activity area */
                 ,defect_priority               /* Defect priority          */
                 ,action_cat                    /* Action category          */
                 ,heid                          /* Selected highway element */
                 ,target_date                   /* Output target date       */
                 ,error_code                    /* Returned error code      */
                 )
long int seqid                                  
        ,heid
        ,*error_code
;
char inspdate[7]
    ,activity_area[3]
    ,defect_priority[5]
    ,action_cat[3]
    ,*target_date[7]
;
{

      EXEC SQL BEGIN DECLARE SECTION;
      varchar  v_inspdate[7]                    /* Inspection date variable */
              ,v_activity_area[3]               /* Activity area            */ 
              ,v_defect_priority[5]             /* Defect priority          */
              ,v_action_cat[3]                  /* Action category          */
              ,v_int_code[5]                    /* Interval code            */
              ,v_use_working_days[2]            /* Working days variable    */
              ,v_use_next_insp[2]               /* Use next inspection var. */
              ,v_target[7]                      /* Target date              */
      ;
      long int v_heid                           /* Highways element         */
              ,v_error                          /* Error number             */
      ;
      varchar v_target_date[12]                 /* Target repair date       */
             ,v_conv_date[12]
      ;
      EXEC SQL END DECLARE SECTION;
    
      strcpy((char*)v_inspdate.arr,inspdate);
      strcpy((char*)v_activity_area.arr,activity_area);
      strcpy((char*)v_defect_priority.arr,defect_priority);
      strcpy((char*)v_action_cat.arr,action_cat);
      v_heid=heid;

      slen_varchar(v_inspdate);            /* Set inspection variable length */ 
      term_varchar(v_inspdate);            /* Term inspection variable       */
      slen_varchar(v_activity_area);       /* Set activity length            */
      term_varchar(v_activity_area);       /* Term activity variable         */
      slen_varchar(v_defect_priority);     /* Set defect priority length     */
      term_varchar(v_defect_priority);     /* Term defect priority variable  */
      slen_varchar(v_action_cat);          /* Set action category length     */
      term_varchar(v_action_cat);          /* Term action category length    */

      if ((EXDebug) && ( K_REC || L_REC || M_REC || N_REC ))
      {
         printf("Inspection date     : %s\n",(char*)v_inspdate.arr);
         printf("Activity   area     : %s\n",(char*)v_activity_area.arr);
         printf("Defect     priority : %s\n",(char*)v_defect_priority.arr);
         printf("Action     category : %s\n",(char*)v_action_cat.arr);
         printf("Rse He Id           : %d\n",v_heid);
      }

     EXEC SQL WHENEVER SQLERROR   CONTINUE; 
     EXEC SQL WHENEVER SQLWARNING CONTINUE; 

     printf ("get_due_date1 sqlca.sqlcode is %d\n",sqlca.sqlcode);
     v_target_date.len=6;
     v_error = 0;
     EXEC SQL EXECUTE
     DECLARE
       v_err       number:=0;
       target_date date;
       char_date   varchar2(20);
     BEGIN
       --
       mai.rep_date_due(to_date(:v_inspdate,'RRMMDD')
                       ,:v_activity_area
                       ,:v_defect_priority
                       ,:v_action_cat
                       ,:v_heid
                       ,target_date
                       ,v_err);
       --
       :v_error := v_err;
       --
       if target_date IS NOT NULL
        THEN
           char_date := to_char(target_date,'RRMMDD');
           :v_target_date := char_date;
       else
           :v_error := 8213;
       end if;
       --
     EXCEPTION
      WHEN others
       THEN
          :v_error := 8213;
     END;
     END-EXEC;
     printf ("get_due_date2 sqlca.sqlcode is %d\n",sqlca.sqlcode);

     if(v_error > 0)
       {
       v_target_date.arr[0]='\0';
       v_target_date.len=0;
       }
     else
       {
       v_target_date.len=6;                      /* Set the date length exp.  */
       term_varchar(v_target_date);              /* Terminate return value    */
       }
     /* Done above 
     EXEC SQL SELECT to_char(to_date(:v_target_date,'DD-MON-YYYY'),'RRMMDD')
         into :v_conv_date
         from dual;
     printf ("get_due_date3 sqlca.sqlcode is %d\n",sqlca.sqlcode);

     v_conv_date.len=6;
     term_varchar(v_conv_date);
     strcpy((char*)v_target_date.arr,(char*)v_conv_date.arr);
     v_target_date.len=6;
     */
     strcpy(target_date,v_target_date.arr);    /* Return date YYMMDD        */
     
     if (( v_target_date.len == 0 ) || ( v_error > 0 ))
     {
        *error_code=v_error;
        return(FAIL);
     }
     else 
        return(SUCCESS);

     rec_err:
        return(FAIL); 
}

/* ===========================================================================
 * Function : validate_job_item()
 * Purpose  : Validate the passed job item and enure that the job item exists. 
 *            return the job item description and job rate.  
 * Params   : Standard item code. [In] ,Total Quantity [IN]
 *            Job name [Out] Job Rate [Out] 
 *            Should return an error if the standard item does not exist OR
 *            if the ;specified quantity is not between the Min/Max quantity
 *            maintained on the standard item.
 * ===========================================================================
 */
int validate_job_item( job_item
                      ,job_quantity
                      ,job_name
                      ,job_rate
                      ,job_labour_unit )
char job_item[10] 
    ,job_quantity[12]
    ,*job_name[40]
;
float *job_rate
     ,*job_labour_unit
;

{
    strcpy(v_job_item.arr,job_item);
    slen_varchar(v_job_item);  
    term_varchar(v_job_item);
    strcpy(v_job_quantity.arr,job_quantity);
    slen_varchar(v_job_quantity);  
    term_varchar(v_job_quantity);

    if ((EXDebug) && (Q_REC))
    {
       printf("Standard Item : %s\n",v_job_item.arr);
       printf("Job quantity  : %s\n",v_job_quantity.arr);
    }

    EXEC SQL WHENEVER SQLERROR   CONTINUE;
    EXEC SQL WHENEVER SQLWARNING CONTINUE;
    EXEC SQL WHENEVER NOT FOUND  CONTINUE;
 
    EXEC SQL SELECT  sta_item_name
                    ,nvl(sta_rate,1)
                    ,nvl(sta_labour_units,1)
             INTO    :v_job_name:i_job_name
                    ,:v_job_rate:i_job_rate
                    ,:v_job_labour:i_job_labour
             FROM    standard_items
             WHERE   sta_item_code = :v_job_item
             AND     to_number(:v_job_quantity)
             BETWEEN sta_min_quantity
             AND     sta_max_quantity;

       term_varchar(v_job_name);     /* Terminate the BOQ job description   */

       strcpy(job_name,v_job_name.arr); /* Copy the BOQ item description    */
       *job_rate=v_job_rate;
       *job_labour_unit=v_job_labour;

       if (ORANOREC)
          return(FALSE);
       else
          return(TRUE);
}          
    
/* ===========================================================================
 * Function : validate_xsp()
 * Purpose  : Validate the xsp value for a defect for the selected section. 
 *            If the xsp value exists then return success else return failure.
 * Params   : Inv Code [In] , Xsp [In] , Rse He Id [In] , Inspection Date [In] 
 * ===========================================================================
 */
int validate_xsp( item_code,xsp,heid,inspdate)
{
    if ((EXDebug) && (I_REC))
    {
          printf("Inventory : %s\n",item_code);  
          printf("XSP       : %s\n",xsp);
          printf("Heid      : %d\n",heid);
          printf("Inspdate  : %s\n",inspdate);
    }

    strcpy(v_xsp.arr,xsp);               /* Set the xsp variable value    */
    strcpy(v_item_code.arr,item_code);   /* Set the inventory item code   */
    strcpy(v_inspdate.arr,inspdate);     /* Set the inspection date value */
    v_rse_he_id=heid;                    /* Set the highways element value*/
    slen_varchar(v_xsp);                 /* Set the xsp variable length   */
    term_varchar(v_xsp);                 /* Terminate the xsp value       */
    slen_varchar(v_item_code);           /* Set the inv code length       */
    term_varchar(v_item_code);           /* Terminate the inv code        */
    slen_varchar(v_inspdate);            /* Set the in,spection date len  */ 
    term_varchar(v_inspdate);            /* Tferminate the inspection date*/
   
    EXEC SQL WHENEVER SQLWARNING CONTINUE;
    EXEC SQL WHENEVER SQLERROR   CONTINUE;  
    
/*******************************************/
/* SQL Below Replaced For Version 3        */
/* Changed xsr_ity_sys_flag To xsr_nw_type */
/*******************************************/
/*
    EXEC SQL SELECT 1 
               INTO :v_exists
               FROM hig_codes      rba
                   ,xsp_restraints xsr
                   ,road_segs      rse
              WHERE rba.hco_domain       = 'XSP_VALUES'
                AND rba.hco_code         = :v_xsp
                AND rse.rse_he_id        = :v_rse_he_id
                AND xsr.xsr_scl_class    = rse.rse_scl_sect_class
                AND xsr.xsr_x_sect_value = :v_xsp
                AND xsr.xsr_ity_inv_code = :v_item_code
                AND xsr.xsr_ity_sys_flag = rse.rse_sys_flag 
                AND to_date(:v_inspdate,'RRMMDD')
                    BETWEEN nvl(rba.hco_start_date,to_date(:v_inspdate,'RRMMDD'))
                        AND nvl(rba.hco_end_date  ,to_date(:v_inspdate,'RRMMDD'))
                  ;
*/

    EXEC SQL SELECT 1 
               INTO :v_exists
               FROM hig_codes      rba
                   ,xsp_restraints xsr
                   ,road_segs      rse
              WHERE rba.hco_domain       = 'XSP_VALUES'
                AND rba.hco_code         = :v_xsp
                AND rse.rse_he_id        = :v_rse_he_id
                AND xsr.xsr_scl_class    = rse.rse_scl_sect_class
                AND xsr.xsr_x_sect_value = :v_xsp
                AND xsr.xsr_ity_inv_code = :v_item_code
                AND xsr.xsr_nw_type      = rse.rse_sys_flag 
                AND to_date(:v_inspdate,'RRMMDD')
                    BETWEEN nvl(rba.hco_start_date,to_date(:v_inspdate,'RRMMDD'))
                        AND nvl(rba.hco_end_date  ,to_date(:v_inspdate,'RRMMDD'))
                  ;

     if (!ORANOREC)
        return(TRUE);
     else
        return(FALSE); 
}


/* ============================================================================
 * Function : get_section_descr() 
 * Purpose  : Obtain the section description for the supplied highways element 
 *            This function will be used primarily by the document insertion 
 *            part of the program and is referenced within r4prorrec.pc 
 * ============================================================================
 */
int get_section_descr(heid,sectdesc) 
long int heid                                         /* Highways element    */
;
char *sectdesc[61]                                    /* Section description */
;
{                     
    EXEC SQL BEGIN DECLARE SECTION;
    varchar v_sectdesc[61]
           ,v_rseunique[21]
    ;
    
    long int v_heid
    ;
    short    i_sectdesc
            ,i_rseunique
    ;
    EXEC SQL END DECLARE SECTION;

    v_heid=heid;

    EXEC SQL WHENEVER SQLWARNING GOTO sect_err;
    EXEC SQL WHENEVER NOT FOUND  GOTO sect_err;
    EXEC SQL WHENEVER SQLERROR   GOTO sect_err;

    EXEC SQL SELECT substr(rse_unique||' '||rse_descr,1,60)
             INTO   :v_sectdesc:i_sectdesc
             FROM   road_segments_all
             WHERE  rse_he_id = :v_heid;

    term_varchar(v_sectdesc);
    strcpy(sectdesc,v_sectdesc.arr);

    EXEC SQL WHENEVER SQLERROR do sql_err("get_section_descr(1)");
    return(SUCCESS);
 
    sect_err:
       EXEC SQL WHENEVER SQLERROR do sql_err("get_section_descr(2)");
       return(FAIL);
} 

/* ============================================================================
 * Function : get_person_admin()
 * Purpose  : Obtain the admin unit for the specified person identification
 *            code. 
 *            If the inspectors administration unit is not located then just
 *            return a failues status. 
 * ============================================================================
 */

int get_person_admin( person_id,admin_unit,inspdate)
int person_id
   ,*admin_unit
;
char inspdate[7]
;
{

     EXEC SQL BEGIN DECLARE SECTION;
     long int v_person_id
             ,v_admin_unit
     ;
     varchar  v_inpdate[7]
     ;
     short int i_admin_unit
     ;
     EXEC SQL END DECLARE SECTION;

     EXEC SQL WHENEVER SQLERROR   GOTO per_err;
     EXEC SQL WHENEVER SQLWARNING GOTO per_err;
     EXEC SQL WHENEVER NOT FOUND  GOTO per_err;

     v_person_id=person_id;
     strcpy(v_inspdate.arr,inspdate);
     slen_varchar(v_inspdate);
     term_varchar(v_inspdate);

     EXEC SQL SELECT  hus_admin_unit
              INTO    :v_admin_unit:i_admin_unit
              FROM    hig_users
              WHERE   hus_user_id = :v_person_id
              AND     to_date(:v_inspdate,'RRMMDD')
              BETWEEN nvl(hus_start_date,to_date(:v_inspdate,'RRMMDD'))
              AND     nvl(hus_end_date  ,to_date(:v_inspdate,'RRMMDD'));

     *admin_unit=v_admin_unit;

     EXEC SQL WHENEVER SQLERROR do sql_err("get_person_admin(1)");
     return(SUCCESS);
   
     per_err:
        EXEC SQL WHENEVER SQLERROR do sql_err("get_person_admin(2)");
        return(FAIL);

}
    
/* ============================================================================
 * Function : get_defect_avail()
 * Purpose  : Obtain the defect availablity code. 
 *            This ia only appropreate to new defects entered into the system. 
 * ============================================================================
 */
int get_status_code(whichcode,status_value)
int whichcode
;
char *status_value[11]
;
{
    int    ret_val=0;
    int    i=0;

    c_ptr= &code_values[0];
    while (1) 
    {
      if ((c_ptr->code_type==whichcode ))
      {
         strcpy(status_value,c_ptr->code_value);
         ret_val=1;
         break;
      }
      else
      {
         *c_ptr++;
         i++;
      }

      if (( i==MAXCODES ) || ( c_ptr->code_type==0))
         break;

     }

     return(ret_val);
}

/* ============================================================================
 * Function : update_sect_last_updated()
 * Purpose  : Update the last inspection date for a specified section.
 *            Parameters required are highways element and date of inspection. 
 * ============================================================================
 */
int update_sect_last_updated(heid,inspdate)
long int heid                                      /* Highways element       */
;
char inspdate[7]                                   /* Inspection date        */
;
{
     EXEC SQL BEGIN DECLARE SECTION;

     long int v_heid
     ;
     int v_error
     ;
     varchar  v_inspdate[7]
     ;

     EXEC SQL END DECLARE SECTION;

     EXEC SQL WHENEVER SQLERROR   GOTO sec_err; 
     EXEC SQL WHENEVER SQLWARNING GOTO sec_err;
     EXEC SQL WHENEVER NOT FOUND  GOTO sec_err;

     v_heid=heid;
     strcpy(v_inspdate.arr,inspdate);
     slen_varchar(v_inspdate);
     term_varchar(v_inspdate);

     if(EXDebug)
       {
       printf("RSE HE ID : %d\n",v_heid);
       printf("Inspdate  : %s\n",v_inspdate.arr);
       }
     /* road_segs is a translation view so the update below will not work.
     || 
     EXEC SQL UPDATE road_segs 
              SET    rse_last_inspected = to_date(:v_inspdate,'RRMMDD')
              WHERE  rse_he_id          = :v_heid; 
     */
     v_error = 0;
     EXEC SQL EXECUTE
     DECLARE
       --
       lv_attrib_name nm_inv_type_attribs_all.ita_attrib_name%TYPE;
       lv_iit_ne_id   nm_inv_items_all.iit_ne_id%TYPE;
       lv_string      nm3type.max_varchar2;
       --
     BEGIN
       select ita_attrib_name
         into lv_attrib_name
         from nm_inv_type_attribs
        where ita_inv_type = (select nad_inv_type
                                from nm_nw_ad_types
                               where exists(select 1
                                              from nm_elements_all
     		                        where ne_id = :v_heid
     				          and ne_nt_type = nad_nt_type
     					  and nvl(ne_gty_group_type,'$$$') = nvl(nad_gty_type,'$$$')
     					  and nad_primary_ad = 'Y'))
          and upper(ita_view_col_name) = 'RSE_LAST_INSPECTED'
            ;
       --
       select nad_iit_ne_id
         into lv_iit_ne_id
         from nm_nw_ad_link
        where nad_ne_id = :v_heid
          and nad_primary_ad = 'Y'
            ;
       --
       lv_string := 'update nm_inv_items set '||lv_attrib_name||' = to_date('
                    ||nm3flx.string(:v_inspdate)||','||nm3flx.string('RRMMDD')
                    ||') where iit_ne_id = '||lv_iit_ne_id;
       --
       execute immediate lv_string;
       --
     EXCEPTION
      WHEN others
       THEN
          :v_error := 1;
     END;
     END-EXEC;

     EXEC SQL WHENEVER SQLERROR do sql_err("update_sect_last_updated(1)");

     if(v_error)
       {
       return(FAIL);
       }
     else
       {
       return(SUCCESS);
       }
sec_err:
  EXEC SQL WHENEVER SQLERROR do sql_err("update_sect_last_updated(2)");

  return(FAIL);
}

BOOLEAN get_ch_option(char p_sys_flag)
{

   EXEC SQL BEGIN DECLARE SECTION;
      varchar use_chainage[2];
			varchar l_hop_id[12];
   EXEC SQL END DECLARE SECTION;

	 if ( p_sys_flag == 'L' )
	 {
	   strcpy(l_hop_id.arr,"USEDEFCHNL");
     slen_varchar(l_hop_id);
     term_varchar(l_hop_id);
	 }
	 if ( p_sys_flag == 'D' )
	 {
	   strcpy(l_hop_id.arr,"USEDEFCHND");
     slen_varchar(l_hop_id);
     term_varchar(l_hop_id);
	 }


   EXEC SQL WHENEVER SQLERROR   GOTO sec_err;
   EXEC SQL WHENEVER SQLWARNING GOTO sec_err;
   EXEC SQL WHENEVER NOT FOUND  GOTO sec_err;
      
   EXEC SQL SELECT HOP_VALUE
            INTO   :use_chainage
            FROM    HIG_OPTIONS
		    WHERE   HOP_ID= :l_hop_id
		    AND     HOP_PRODUCT='MAI';
   oraerror("get_ch_option");

   if (use_chainage.arr[0] == 'Y')
      return(TRUE);
   else
      return(FALSE);

   sec_err:
     EXEC SQL WHENEVER SQLERROR do sql_err("get_ch_option");
     return(FAIL);
}
