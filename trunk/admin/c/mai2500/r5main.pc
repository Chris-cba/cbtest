
/* SCCS ID keywords, do not remove */
/* Copyright (c) 2013 Bentley Systems Incorporated. All rights reserved. */

static char *sccsid = "@(#)r5main.pc	1.1 09/16/03";

/**********************************************************************
*                                                                     *
*   REPORT  : BPR2500 Inventory Interface File                        *
*                                                                     *
*                                                                     *
*   AUTHOR  : G.Dutton     - Oracle Corp UK.                          *
*   VERSION : 1.0                                                     *
*   DATE    : 11 April 1991                                           *
*   DESCRIPTION  :-                                                   *
*    i)    Unloads data for DTP NIS Lighting Point Application.       *
*    ii)   Unloads Data in Husky Hunter Format.                       *
*    Options :           H - Husky Hunter Format                      *
*                        N - No off site info                         *
*                        D - Descending order of C card chainage      *
*                        S - Print section description in B card      *
*                        T - Trace SQL parsed by Oracle               *
*                        B - Do not print banner                      *
*                        ? - Print parameter help message             *
*                                                                     *
*   CHANGE HISTORY :-                                                 *
*    DATE         : 03-Feb-93                                         *
*    CHANGED BY   : Rod Strong                                        *
*    DESCRIPTION  : Add calls to oralogoff before error exits.        *
*                                                                     *
*    DATE         : 09-FEB-95                                         *
*    CHANGED BY   : Graham Dutton                                     *
*    DESCRIPTION  : Added additional paramater to allow production    * 
*                   of section description in B cards when required.  *
*                                                                     *
*     DATE         : 04-11-97
*     CHANGED BY   : G Fletcher
*     DESCRIPTION  : client-server conversion
**********************************************************************/

/************************************************************ 
* Standard I/O definition and rmms header file.             *
************************************************************/ 
#include <stdio.h>
#include <ctype.h>
#include "rmms.h"

EXEC SQL BEGIN DECLARE SECTION;
	VARCHAR d_inits[4];
EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE sqlext.h;

short EXDebug;
char *EXRepOutpath;
char pipe_msg[254];

char dbase_string[6];


/************************************************************ 
* Program Entry point.                                      *
************************************************************/ 

int main(argc,argv)
char *argv[];
int  argc;
{
   int dbase_type();
   void set_sys_flag();
   char inits[4];    
   FILE *iif_report();
   FILE *fp;
   int i,j;
   int no_of_c_inv = 0 ,no_of_d_inv = 0 ,no_of_sec = 0;
   char mod_name[10];

	jobmain(argc,argv);

   j=0;

   base_name(mod_name,argv[0]);

   get_params(2); /* Two mandatory params */

   if ( (strcmp(mod_name,"mai2500")==0) ||
        (strcmp(mod_name,"mai2500.exe")==0) )
   {
      par_set('H','S');
      par_set('N','S');
      printf ("INFO: MAI2500 Called and Running in DCD Mode.\n");
      write_pipe(NULL,"INFO: MAI2500 Called and Running in DCD Mode.");
   }
   else
   {
      printf ("INFO: MAI2500 Called and Running in IIF Mode.\n");
      write_pipe(NULL,"INFO: MAI2500 Called and Running in IIF Mode.");
   }

/*
  	if (EXParamCount > 3 && EXParam[3].len > 0)
	{
  		for (i=0;i<strlen((char *)EXParam[3].arr);i++)
	  	{
     		switch (EXParam[3].arr[i])
     		{
     			case 'H' : 
     			case 'D' :
     			case 'S' :
     			case 'T' :
     			case 'B' :
     			case 'N' : 
					par_set(EXParam[3].arr[i],'S');
                	break;
			}
    	}
  	}
*/
	
if (par_set('T','C') == 1) { trace_on(); }

if (par_set('B','C') != 1)
{
  if (dbase_type() == 3 || dbase_type() == 4)
     strcpy(dbase_string,"MMGR");
  else
     strcpy(dbase_string,"RMMS");
} 

   set_sys_flag(atoi(EXParam[0].arr));

   /************************************************************ 
    * Get Inspectors Initials if Husky Hunter Format File      *
    ************************************************************/ 

if (par_set('H','C') == 1)
{ 
	EXEC SQL 
		SELECT HUS_INITIALS 
		INTO :d_inits
		FROM HIG_USERS
		WHERE HUS_USERNAME=user;
        printf ("");
	term_varchar(d_inits);
        printf ("");
	strcpy(inits,(char *)d_inits.arr);
        printf ("");
}

   /************************************************************ 
    * Get Inventory Selection Criteria
    ************************************************************/ 

   	if (sel_inventory() ==0)
	{
		jobend(EXJobId,0,"");
		EXEC SQL COMMIT WORK;
		dblogoff();
		exit(0);
	}

   /************************************************************ 
    * Accept user input of CHART selection crieria.            *
    ************************************************************/ 

    if (sel_chart() == 0)
	{
		jobend(EXJobId,0,"");
		EXEC SQL COMMIT WORK;
		dblogoff();
		exit(0);
	}

   /************************************************************ 
    * Generate report for inventory and CHART selections       *
    ************************************************************/ 

    fp = iif_report(inits,&no_of_c_inv,&no_of_d_inv,&no_of_sec);


  if (par_set('H','C') == 1)
  {  
    fprintf(fp,"\n\"Z,%4d,%4d\"\n",no_of_sec,no_of_c_inv); 
  }
  else
  {  
    fprintf(fp,"\n\"Z,%4d,%6d,%6d\"\n",no_of_sec,no_of_c_inv,no_of_d_inv);
  }


        printf ("INFO: Report successfully completed\n");
        write_pipe(NULL,"INFO: Report successfully completed");
	jobend(EXJobId,0,"");
	EXEC SQL COMMIT WORK;
	dblogoff();
	exit(EX_SUCC);
}

/************************************************************ 
* Function : par_set()                                      *
* sets or checks parameter settings.                        *
************************************************************/ 

int par_set(par,set_or_check)
char par;
char set_or_check;
{
static char par_str[10];
static int count=0;

if (set_or_check == 'S')
{
  if (count >= 9)
  {
    printf("\n ERROR : Too many parameters specified");
    printf(" BPR-0385\n");
    write_pipe(NULL,"ERROR : Too many parameters specified BPR-0385");
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,0,"Too many parameters specified BPR-0385");
	EXEC SQL COMMIT WORK;
	dblogoff();
    exit(EX_FAIL);
  }
  else
  {
    par_str[count] = par;
    count++;
    return(1);
  }
}
else if (strchr(par_str,par) != NULL)      
     {  return(1); }
else 
     {  return(-1); }
}   

void usersigfunc(sig)
int sig;
{
        char temp[10];

	printf("Signal %d received. Aborting ...",sig);
        strcpy(pipe_msg,"Signal ");
        i_toa(sig,temp);
        strcat(pipe_msg,temp);
        strcat(pipe_msg," received. Aborting ...");
        write_pipe(NULL,pipe_msg);
	EXEC SQL ROLLBACK WORK;
	jobend(EXJobId,1,"Signal received causing abnormal program termination");
	EXEC SQL COMMIT WORK;
}

base_name(mod_name,full_path)
char *mod_name, *full_path;
{
   int i,j;
   int pos_of_slash;
   int slash_found=FALSE;

   slash_found = FALSE;
   for (i=strlen(full_path);i>=0;i--)
   {
      if ((full_path[i] != '/') && (full_path[i] != '\\'))
         ;
      else
      {
         pos_of_slash = i;
         slash_found = TRUE;
         break;
      }
   }

   j=i=0;
   if (slash_found)
      for (i=pos_of_slash+1;i<=strlen(full_path);i++)
         mod_name[j++]=full_path[i];
   else
      strcpy(mod_name,full_path);

   for (i=0;i<strlen(mod_name);i++)
      mod_name[i] = tolower(mod_name[i]);
}
